
<!-- saved from url=(0102)https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Uboot中start.S源码的指令级的详尽解析</title>
<link rel="stylesheet" type="text/css" href="./Uboot中start.S源码的指令级的详尽解析_files/docbook_crl.css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<meta name="description" content="本文对Uboot中的Start.S的源码的几乎每一行，都进行了详细的解析 本文提供多种格式供：在线阅读HTMLHTMLsPDFCHMTXTRTFWEBHELP下载（7zip压缩包）HTMLHTMLsPDFCHMTXTRTFWEBHELPHTML版本的在线地址为：有任何意见，建议，提交bug等，都欢迎去讨论组发帖讨论：">
<meta name="keywords" content="Uboot, Start.S, 指令级, 每一行, 详解">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<script type="text/javascript" async="" src="./Uboot中start.S源码的指令级的详尽解析_files/ga.js"></script><script type="text/javascript">  var _gaq = _gaq || [];  _gaq.push(['_setAccount', 'UA-28297199-1']);  _gaq.push(['_trackPageview']);  (function() {    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);  })();</script>
<div lang="zh_CN" class="book">
<div class="titlepage">
<div>
<div><h1 class="title">
<a name="idm4142176"></a>Uboot中start.S源码的指令级的详尽解析</h1></div>
<div><p class="releaseinfo">
    版本：<span class="emphasis"><em>v1.9</em></span>
</p></div>
<div><h2 class="subtitle"></h2></div>
<div><div class="author"><h3 class="author">
<span class="firstname">Crifan</span> <span class="surname">Li</span>
</h3></div></div>
<div><div class="abstract">
<p class="title"><b>摘要</b></p>
<p>本文对Uboot中的Start.S的源码的几乎每一行，都进行了详细的解析</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip: 本文提供多种格式供：">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[提示]" src="./Uboot中start.S源码的指令级的详尽解析_files/tip.png"></td>
<th align="left">
<a name="common_multi_format"></a>本文提供多种格式供：</th>
</tr>
<tr><td align="left" valign="top">
<div class="informaltable"><table style="border-collapse: collapse;border-top: 1.5pt solid black; border-bottom: 1.5pt solid black; ">
<colgroup>
<col class="col1">
<col class="col2">
<col class="col3">
<col class="col4">
<col class="col5">
<col class="col6">
<col class="col7">
<col class="col8">
</colgroup>
<tbody>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; " align="center">在线阅读</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; " align="center"><a class="link" href="http://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html" target="_top">HTML</a></td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; " align="center"><a class="link" href="http://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/htmls/index.html" target="_top">HTMLs</a></td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; " align="center"><a class="link" href="http://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/pdf/uboot_starts_analysis.pdf" target="_top">PDF</a></td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; " align="center"><a class="link" href="http://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/chm/uboot_starts_analysis.chm" target="_top">CHM</a></td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; " align="center"><a class="link" href="http://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/txt/uboot_starts_analysis.txt" target="_top">TXT</a></td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; " align="center"><a class="link" href="http://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/rtf/uboot_starts_analysis.rtf" target="_top">RTF</a></td>
<td style="border-bottom: 0.5pt solid green; " align="center"><a class="link" href="http://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/webhelp/index.html" target="_top">WEBHELP</a></td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; " align="center">下载（7zip压缩包）</td>
<td style="border-right: 0.5pt solid green; " align="center"><a class="link" href="http://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html.7z" target="_top">HTML</a></td>
<td style="border-right: 0.5pt solid green; " align="center"><a class="link" href="http://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/htmls/index.html.7z" target="_top">HTMLs</a></td>
<td style="border-right: 0.5pt solid green; " align="center"><a class="link" href="http://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/pdf/uboot_starts_analysis.pdf.7z" target="_top">PDF</a></td>
<td style="border-right: 0.5pt solid green; " align="center"><a class="link" href="http://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/chm/uboot_starts_analysis.chm.7z" target="_top">CHM</a></td>
<td style="border-right: 0.5pt solid green; " align="center"><a class="link" href="http://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/txt/uboot_starts_analysis.txt.7z" target="_top">TXT</a></td>
<td style="border-right: 0.5pt solid green; " align="center"><a class="link" href="http://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/rtf/uboot_starts_analysis.rtf.7z" target="_top">RTF</a></td>
<td style="" align="center"><a class="link" href="http://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/webhelp/uboot_starts_analysis.webhelp.7z" target="_top">WEBHELP</a></td>
</tr>
</tbody>
</table></div>
<p>HTML版本的在线地址为：</p>
<p><a class="link" href="http://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html" target="_top">http://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html</a></p>
<p>有任何意见，建议，提交bug等，都欢迎去讨论组发帖讨论：</p>
<p><a class="link" href="http://www.crifan.com/bbs/categories/uboot_starts_analysis/" target="_top">http://www.crifan.com/bbs/categories/uboot_starts_analysis/</a></p>
</td></tr>
</tbody></table></div>
</div></div>
<div><p class="pubdate">
    2013-09-04
</p></div>
<div><div class="revhistory"><table border="1px solid black" width="100%" summary="修订历史">
<tbody><tr><th align="left" valign="top" colspan="3"><b>修订历史</b></th></tr>
<tr>
<td align="left">修订 1.9</td>
<td align="left">2013-09-04</td>
<td align="left">crl</td>
</tr>
<tr><td align="left" colspan="3">
                <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">通过Docbook发布</li>
<li class="listitem">修正了一些琐碎的笔误，同时增添了些琐碎内容</li>
<li class="listitem">修正了0xdeadbeef的解释</li>
<li class="listitem">更新了所有的xml:id</li>
</ol></div>
            </td></tr>
<tr>
<td align="left">修订 1.6</td>
<td align="left">2011-05-01</td>
<td align="left">crl</td>
</tr>
<tr><td align="left" colspan="3">
                <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">添加汇编学习记录</li>
<li class="listitem">添加了如何查看C或汇编的源代码所对应的真正的汇编代码</li>
<li class="listitem">添加Start.S的总结
                        <div class="orderedlist"><ol class="orderedlist" type="a">
<li class="listitem">Start.S的各个部分的总结</li>
<li class="listitem">Uboot中的内存的layout</li>
</ol></div>
</li>
<li class="listitem">更加详细地解释了为何ARM9中PC=PC+8</li>
<li class="listitem">添加了一些其他的细节的内容</li>
<li class="listitem">修正一些拼写错误</li>
</ol></div>
            </td></tr>
<tr>
<td align="left">修订 1.0</td>
<td align="left">2011-04-17</td>
<td align="left">crl</td>
</tr>
<tr><td align="left" colspan="3">
                <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">详细解释了uboot的start.s中的每行代码</li>
<li class="listitem">添加了相关知识点的详细解释</li>
</ol></div>
            </td></tr>
</tbody></table></div></div>
<div><p class="copyright">版权 © 2013 Crifan, <a class="link" href="http://crifan.com/" target="_top">http://crifan.com</a></p></div>
<div><div class="legalnotice">
<a name="common_legalnotice"></a><p>本文章遵从：<a class="link" href="http://www.crifan.com/files/doc/docbook/soft_dev_basic/release/html/soft_dev_basic.html#cc_by_nc" target="_top">署名-非商业性使用 2.5 中国大陆(CC BY-NC 2.5)</a></p>
</div></div>
</div>
<hr>
</div>
<div class="toc">
<p><b>目录</b></p>
<dl class="toc">
<dt><span class="preface"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#preface">正文之前</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#idp1229808">1. 本文内容</a></span></dt>
<dt><span class="section"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#idp1105888">2. 本文目标</a></span></dt>
<dt><span class="section"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#idp1152512">3. 代码来源</a></span></dt>
<dt><span class="section"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#idp1154024">4. 阅读此文所要具有的前提知识</a></span></dt>
<dt><span class="section"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#idp1155296">5. 声明</a></span></dt>
</dl></dd>
<dt><span class="chapter"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#ch01_starts_explanation">1. start.S详解</a></span></dt>
<dd><dl>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#ch01s1_set_cpu_mode">1.1. 设置CPU模式</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#globl">1.1.1. globl</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#_start">1.1.2. _start</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#ldr">1.1.3. ldr</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#dot_word">1.1.4. .word</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#dot_balignl">1.1.5. .balignl</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#_text_base__armboot_start">1.1.6. _TEXT_BASE _armboot_start</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#_bss_start__bss_end">1.1.7. _bss_start _bss_end</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#free_ram_end_free_ram_size">1.1.8. FREE_RAM_END FREE_RAM_SIZE</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#irq_stack_start_fiq_stack_start">1.1.9. IRQ_STACK_START FIQ_STACK_START</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#cpsr">1.1.10. cpsr</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#bic">1.1.11. bic</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#orr">1.1.12. orr</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#msr">1.1.13. msr</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#ch01s2_close_watchdog">1.2. 关闭看门狗</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#pwtcon_intmod_intmsk_intsubmsk_clkdivn">1.2.1. pWTCON INTMOD INTMSK INTSUBMSK CLKDIVN</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#ldr_pwtcon">1.2.2. ldr pWTCON</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#mov">1.2.3. mov</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#str">1.2.4. str</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#ch01s3_disable_interrupt">1.3. 关闭中断</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#set_intmsk">1.3.1. set INTMSK</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#set_intsubmsk">1.3.2. set INTSUBMSK</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#set_clkdivn">1.3.3. set CLKDIVN</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#bl">1.3.4. bl</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#ch01s4_setup_stack_pointer">1.4. 设置堆栈sp指针</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#stack_setup">1.4.1. stack_setup</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#calc_stack">1.4.2. calc stack</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#bl_clock_init">1.4.3. bl clock_init</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#adr">1.4.4. adr</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#clear_bss">1.4.5. clear_bss</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#_armboot_start">1.4.6. cal armboot size from _armboot_start</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#copycode2ram">1.4.7. cal armboot size from CopyCode2Ram</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#ch01s5_clear_bss">1.5. 清除bss段</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#clear_bss_stack">1.5.1. clear_bss</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#clear_css_loop">1.5.2. clear css loop</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#ldr_pc">1.5.3. ldr pc</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#cpu_init_crit">1.5.4. cpu_init_crit</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#disable_mmu">1.5.5. disable MMU</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#clear_bits">1.5.6. clear bits</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#bl_lowlevel_init">1.5.7. bl lowlevel_init</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#ch01s6_handle_exception">1.6. 异常中断处理</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#macros_stmia">1.6.1. macros stmia</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#cal_reg_value_and_store">1.6.2. cal reg value and store</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#irq_save_user_regs_irq_restore_user_regs">1.6.3. irq_save_user_regs irq_restore_user_regs</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#exception_handlers">1.6.4. exception handlers</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#launch">1.6.5. Launch</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#int_return">1.6.6. int_return</a></span></dt>
</dl></dd>
</dl></dd>
<dt><span class="chapter"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#ch02_starts_summary">2. start.S的总结</a></span></dt>
<dd><dl>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#start_s_summary">2.1. start.S各个部分的总结</a></span></dt>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#uboot_mem_layout">2.2. Uboot中的内存的Layout</a></span></dt>
</dl></dd>
<dt><span class="chapter"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#ch03_related_knowledge">3. 相关知识点详解</a></span></dt>
<dd><dl>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#how_to_see_real_assembly">3.1. 如何查看C或汇编的源代码所对应的真正的汇编代码</a></span></dt>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#why_svc_not_other">3.2. uboot初始化中，为何要设置CPU为SVC模式而不是设置为其他模式</a></span></dt>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#why_close_wdt">3.3. 什么是watchdog + 为何在要系统初始化的时候关闭watchdog</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#idp3122432">3.3.1. 什么是watchdog</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#idp3125440">3.3.2. 为何在要系统初始化的时候关闭watchdog</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#why_arm7_pc_8">3.4. 为何ARM7中PC=PC+8</a></span></dt>
<dd><dl><dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#idp3138744">3.4.1. 为何ARM9和ARM7一样，也是PC=PC+8</a></span></dt></dl></dd>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#arm_reg_name_apcs">3.5. AMR寄存器的别名 + APCS</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#arm_reg_alias">3.5.1. ARM中的寄存器的别名</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#what_is_apcs">3.5.2. 什么是APCS</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#why_c_need_stack">3.6. 为何C语言（的函数调用）需要堆栈，而汇编语言却不需要堆栈</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#save_context">3.6.1. 保存现场/上下文</a></span></dt>
<dd><dl><dt><span class="sect3"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#idp1816936">3.6.1.1. 什么叫做上下文context</a></span></dt></dl></dd>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#pass_parameter">3.6.2. 传递参数</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#exampe_show_c_stack">3.6.3. 举例分析C语言函数调用是如何使用堆栈的</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#why_adr_not_move">3.7. 关于为何不直接用mov指令，而非要用adr伪指令</a></span></dt>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#mov_value_range">3.8. mov指令的操作数的取值范围到底是多少</a></span></dt>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#summary_assembly">3.9. 汇编学习总结记录</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#assembly_label_c_label">3.9.1. 汇编中的标号=C中的标号</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#assembly_b_c_goto">3.9.2. 汇编中的跳转指令=C中的goto</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#assembly_globl_c_extern">3.9.3. 汇编中的.globl=C语言中的extern</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#bl_mov_pc_lr_mean_func_call">3.9.4. 汇编中用bl指令和mov pc，lr来实现子函数调用和返回</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#assembly_label_c_pointer">3.9.5. 汇编中的对应位置有存储值的标号 = C语言中的指针变量</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#assembly_ldr_c_func_call">3.9.6. 汇编中的ldr+标号，来实现C中的函数调用</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#assembly_set_value_for_reg">3.9.7. 汇编中设置某个寄存器的值或给某个地址赋值</a></span></dt>
</dl></dd>
</dl></dd>
<dt><span class="bibliography"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#reference">参考书目</a></span></dt>
</dl>
</div>
<div class="list-of-figures">
<p><b>插图清单</b></p>
<dl>
<dt>1.1. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#fg.ldr_syntax">LDR指令的语法</a>
</dt>
<dt>1.2. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#fg.cpsr_spsr_bit_field">CPSR/SPSR的位域结构</a>
</dt>
<dt>1.3. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#fg.pwtcon">pWTCON</a>
</dt>
<dt>1.4. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#fg.intmod">INTMOD</a>
</dt>
<dt>1.5. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#fg.intmsk">INTMSK</a>
</dt>
<dt>1.6. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#fg.intsubmsk">INTSUBMSK</a>
</dt>
<dt>1.7. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#fg.clkdivn">CLKDIVN</a>
</dt>
<dt>1.8. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#fg.wtcon_reg_bits">WTCON寄存器的位域</a>
</dt>
<dt>1.9. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#fg.intmsk_reg_bits">INTMSK寄存器的位域</a>
</dt>
<dt>1.10. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#fg.intsubmsk_reg_bits">INTSUBMSK寄存器的位域</a>
</dt>
<dt>1.11. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#fg.clkdivn_reg_bits">INTSUBMSK寄存器的位域</a>
</dt>
<dt>1.12. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#fg.macro_syntax">macro的语法</a>
</dt>
<dt>1.13. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#fg.ldm_stm_syntax">LDM/STM的语法</a>
</dt>
<dt>1.14. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#fg.cond_format">条件码的含义</a>
</dt>
<dt>2.1. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#fg.uboot_mem_layout">Uboot中的内存的Layout</a>
</dt>
<dt>3.1. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#fg.arm_3_tie_pipeline">AMR7三级流水线</a>
</dt>
<dt>3.2. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#fg.arm_3_tie_pipeline_state">ARM7三级流水线状态</a>
</dt>
<dt>3.3. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#fg.arm_3_tie_pipeline_example">ARM7三级流水线示例</a>
</dt>
<dt>3.4. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#fg.arm7_3tie_vs_arm9_5tie">ARM7三级流水线 vs ARM9五级流水线</a>
</dt>
<dt>3.5. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#fg.arm7_3tie_mapping_arm9_5tie">ARM7三级流水线到ARM9五级流水线的映射</a>
</dt>
<dt>3.6. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#fg.arm9_5tie_pipeline">ARM9的五级流水线示例</a>
</dt>
<dt>3.7. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#fg.arm9_5tie_why_pc8">ARM9的五级流水线中为何PC=PC+8</a>
</dt>
<dt>3.8. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#fg.aapcs">ARM Application Procedure Call Standard (AAPCS)</a>
</dt>
<dt>3.9. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#fg.data_process_instr">数据处理指令的指令格式</a>
</dt>
</dl>
</div>
<div class="list-of-tables">
<p><b>表格清单</b></p>
<dl>
<dt>1.1. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#tbl.global_synopsis">global的语法</a>
</dt>
<dt>1.2. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#tbl.dot_word_syntax">.word的语法</a>
</dt>
<dt>1.3. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#tbl.balignl_syntax">balignl的语法</a>
</dt>
<dt>1.4. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#tbl.cpsr_bitfield">CPSR Bitfield</a>
</dt>
<dt>1.5. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#tbl.cpsr_0xd3_bitfields">CPSR=0xD3的位域及含义</a>
</dt>
<dt>1.6. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#tbl.ctrl_reg1_bits">控制寄存器1的位域含义</a>
</dt>
<dt>1.7. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#tbl.clock_mode">时钟模式</a>
</dt>
<dt>1.8. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#tbl.domain_access_ctrl">关于访问控制位在域访问控制寄存器中的含义</a>
</dt>
<dt>1.9. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#tbl.ap_bits">关于访问允许(AP)位的含义</a>
</dt>
<dt>3.1. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#tbl.arm_cpu_mode">ARM中CPU的模式</a>
</dt>
<dt>3.2. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#tbl.arm_regs_alias">ARM寄存器的别名</a>
</dt>
<dt>3.3. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#tbl.mov_0xe3a00453_bits">mov指令0xe3a00453的位域含义解析</a>
</dt>
</dl>
</div>
<div class="list-of-examples">
<p><b>范例清单</b></p>
<dl>
<dt>3.1. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#idp3302704">汇编中的ldr加标号实现函数调用 示例</a>
</dt>
<dt>3.2. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#idp3312888"></a>
</dt>
<dt>3.3. <a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#idp3314848"></a>
</dt>
</dl>
</div>
<div class="preface">
<div class="titlepage"><div><div><h1 class="title">
<a name="preface"></a>正文之前</h1></div></div></div>
<div class="toc">
<p><b>目录</b></p>
<dl class="toc">
<dt><span class="section"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#idp1229808">1. 本文内容</a></span></dt>
<dt><span class="section"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#idp1105888">2. 本文目标</a></span></dt>
<dt><span class="section"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#idp1152512">3. 代码来源</a></span></dt>
<dt><span class="section"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#idp1154024">4. 阅读此文所要具有的前提知识</a></span></dt>
<dt><span class="section"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#idp1155296">5. 声明</a></span></dt>
</dl>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="idp1229808"></a>1.&nbsp;本文内容</h2></div></div></div>
<p>此文主要内容就是分析start.S这个汇编文件的内容，即ARM上电后的最开始那一段的启动过程。</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="idp1105888"></a>2.&nbsp;本文目标</h2></div></div></div>
<p>本文的目标是，希望看完此文的读者，可以达到：</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">微观上，对此start.S的每一行，都有了基本的了解</li>
<li class="listitem">宏观上，对基于ARM核的S3C24X0的CPU的启动过程，有更加清楚的概念</li>
</ol></div>
<p>这样的目的，是为了读者看完本文后，再去看其他类似的启动相关的源码，能明白需要做什么事情，然后再看别的系统是如何实现相关的内容的，达到一定程度的触类旁通。</p>
<p>总体说就是，要做哪些，为何要这么做，如何实现的，即英语中常说的：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">do what</li>
<li class="listitem">why do</li>
<li class="listitem">how do</li>
</ul></div>
<p>此三方面都清楚理解了，那么也才能算真正懂了。</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="idp1152512"></a>3.&nbsp;代码来源</h2></div></div></div>
<p>所用代码来自TQ2440官网，天嵌的bbs上下载下来的uboot中的源码：</p>
<p><span class="emphasis"><em>u-boot-1.1.6_20100601\opt\EmbedSky\u-boot-1.1.6\cpu\arm920t\start.S</em></span></p>
<p>下载地址为：<a class="ulink" href="http://bbs.embedsky.net/viewthread.php?tid=859" target="_top">2010年6月 最新TQ2440光盘下载 （Linux内核，WinCE的eboot，uboot均有更新）</a></p>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="idp1154024"></a>4.&nbsp;阅读此文所要具有的前提知识</h2></div></div></div>
<p>阅读此文之前，你至少要对TQ2440的板子有个基本的了解，</p>
<p>以及要了解开发板初始化的大概要做的事情，比如设置输入频率，设置堆栈等等。</p>
<p>另外，至少要有一定的C语言的基础，这样更利于理解汇编代码。</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="idp1155296"></a>5.&nbsp;声明</h2></div></div></div>
<p>由于水平有限，难免有误，欢迎指正：admin (at) crifan.com</p>
<p>欢迎转载，但请注明作者。</p>
</div>
</div>
<div class="chapter">
<div class="titlepage"><div><div><h1 class="title">
<a name="ch01_starts_explanation"></a>第&nbsp;1&nbsp;章&nbsp;start.S详解</h1></div></div></div>
<div class="toc">
<p><b>目录</b></p>
<dl class="toc">
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#ch01s1_set_cpu_mode">1.1. 设置CPU模式</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#globl">1.1.1. globl</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#_start">1.1.2. _start</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#ldr">1.1.3. ldr</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#dot_word">1.1.4. .word</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#dot_balignl">1.1.5. .balignl</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#_text_base__armboot_start">1.1.6. _TEXT_BASE _armboot_start</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#_bss_start__bss_end">1.1.7. _bss_start _bss_end</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#free_ram_end_free_ram_size">1.1.8. FREE_RAM_END FREE_RAM_SIZE</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#irq_stack_start_fiq_stack_start">1.1.9. IRQ_STACK_START FIQ_STACK_START</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#cpsr">1.1.10. cpsr</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#bic">1.1.11. bic</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#orr">1.1.12. orr</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#msr">1.1.13. msr</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#ch01s2_close_watchdog">1.2. 关闭看门狗</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#pwtcon_intmod_intmsk_intsubmsk_clkdivn">1.2.1. pWTCON INTMOD INTMSK INTSUBMSK CLKDIVN</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#ldr_pwtcon">1.2.2. ldr pWTCON</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#mov">1.2.3. mov</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#str">1.2.4. str</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#ch01s3_disable_interrupt">1.3. 关闭中断</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#set_intmsk">1.3.1. set INTMSK</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#set_intsubmsk">1.3.2. set INTSUBMSK</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#set_clkdivn">1.3.3. set CLKDIVN</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#bl">1.3.4. bl</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#ch01s4_setup_stack_pointer">1.4. 设置堆栈sp指针</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#stack_setup">1.4.1. stack_setup</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#calc_stack">1.4.2. calc stack</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#bl_clock_init">1.4.3. bl clock_init</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#adr">1.4.4. adr</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#clear_bss">1.4.5. clear_bss</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#_armboot_start">1.4.6. cal armboot size from _armboot_start</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#copycode2ram">1.4.7. cal armboot size from CopyCode2Ram</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#ch01s5_clear_bss">1.5. 清除bss段</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#clear_bss_stack">1.5.1. clear_bss</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#clear_css_loop">1.5.2. clear css loop</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#ldr_pc">1.5.3. ldr pc</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#cpu_init_crit">1.5.4. cpu_init_crit</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#disable_mmu">1.5.5. disable MMU</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#clear_bits">1.5.6. clear bits</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#bl_lowlevel_init">1.5.7. bl lowlevel_init</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#ch01s6_handle_exception">1.6. 异常中断处理</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#macros_stmia">1.6.1. macros stmia</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#cal_reg_value_and_store">1.6.2. cal reg value and store</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#irq_save_user_regs_irq_restore_user_regs">1.6.3. irq_save_user_regs irq_restore_user_regs</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#exception_handlers">1.6.4. exception handlers</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#launch">1.6.5. Launch</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#int_return">1.6.6. int_return</a></span></dt>
</dl></dd>
</dl>
</div>
<div class="abstract"><p class="title"><b>摘要</b></p></div>
<p>下面将详细解释uboot中的start.S中的每一行代码。详细到，每个指令的语法和含义，都进行详细讲解，使得此文读者可以真正搞懂具体的含义，即what。</p>
<p>以及对于一些相关的问题，深入探究为何要这么做，即why。</p>
<p>对于uboot的start.S，主要做的事情就是系统的各个方面的初始化。</p>
<p>从大的方面分，可以分成这几个部分：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem"><span class="emphasis"><em>设置CPU模式</em></span></li>
<li class="listitem"><span class="emphasis"><em>关闭看门狗</em></span></li>
<li class="listitem"><span class="emphasis"><em>关闭中断</em></span></li>
<li class="listitem"><span class="emphasis"><em>设置堆栈sp指针</em></span></li>
<li class="listitem"><span class="emphasis"><em>清除bss段</em></span></li>
<li class="listitem"><span class="emphasis"><em>异常中断处理</em></span></li>
</ul></div>
<p>下面来对start.S进行详细分析，看看每一个部分，是如何实现的。</p>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="ch01s1_set_cpu_mode"></a>1.1.&nbsp;设置CPU模式</h2></div></div></div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="globl"></a>1.1.1.&nbsp;globl</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">/*
 *  armboot - Startup Code for ARM920 CPU-core
 *
 *  Copyright (c) 2001	Marius Gr鰃er &lt;mag@sysgo.de&gt;
 *  Copyright (c) 2002	Alex Z黳ke &lt;azu@sysgo.de&gt;
 *  Copyright (c) 2002	Gary Jennejohn &lt;gj@denx.de&gt;
 *
 * See file CREDITS for list of people who contributed to this
 * project.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 * MA 02111-1307 USA
 */

#include &lt;config.h&gt;
#include &lt;version.h&gt;


/*
 *************************************************************************
 *
 * Jump vector table as in table 3.1 in [1]
 *
 *************************************************************************
 */


.globl<a class="co" name="co.globl" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.globl"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> _start
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.globl"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.globl"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>globl是个关键字，对应含义为：</p>
<a class="ulink" href="http://re-eject.gbadev.org/files/GasARMRef.pdf" target="_top">http://re-eject.gbadev.org/files/GasARMRef.pdf</a><div class="table">
<a name="tbl.global_synopsis"></a><p class="title"><b>表&nbsp;1.1.&nbsp;global的语法</b></p>
<div class="table-contents"><table summary="global的语法" style="border-collapse: collapse;border-top: 1.5pt solid black; border-bottom: 1.5pt solid black; border-left: 1.5pt solid black; border-right: 1.5pt solid black; ">
<colgroup>
<col class="col1">
<col class="col2">
<col class="col3">
<col class="col4">
</colgroup>
<thead><tr>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Directive</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Description</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Syntax</th>
<th style="border-bottom: 0.5pt solid green; ">Example</th>
</tr></thead>
<tbody>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; "><span class="emphasis"><em>.global</em></span></td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Makes <span class="emphasis"><em>symbol</em></span> visible to the linker</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">.global symbol</td>
<td style="border-bottom: 0.5pt solid green; ">
<span class="emphasis"><em>.global</em></span> MyAsmFunc</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; "><span class="emphasis"><em>.globl</em></span></td>
<td style="border-right: 0.5pt solid green; ">Same as <span class="emphasis"><em>.global</em></span>
</td>
<td style="border-right: 0.5pt solid green; ">.globl symbol</td>
<td style="">
<span class="emphasis"><em>.globl</em></span> MyOtherAsmFunc</td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>所以，意思很简单，就是相当于C语言中的Extern，声明此变量，并且告诉链接器此变量是全局的，外部可以访问</p>
<p>所以，你可以看到</p>
<p><code class="filename">u-boot-1.1.6_20100601\opt\EmbedSky\u-boot-1.1.6\board\EmbedSky\u-boot.lds</code></p>
<p>中，有用到此变量:</p>
<p><span class="emphasis"><em>ENTRY(_start)</em></span></p>
<p>即指定入口为_start,而由下面的_start的含义可以得知，_start就是整个start.S的最开始，即整个uboot的代码的开始。</p>
</td>
</tr></tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="_start"></a>1.1.2.&nbsp;_start</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">_start<a class="co" name="co._start" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note._start"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>:	b       reset
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note._start"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co._start"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>_start后面加上一个冒号’:’，表示其是一个标号Label，类似于C语言goto后面的标号。</p>
<p>而同时，_start的值，也就是这个代码的位置了，此处即为代码的最开始，相对的0的位置。</p>
<p>而此处最开始的相对的0位置，在程序开始运行的时候，如果是从NorFlash启动，那么其地址是0，</p>
<p><span class="emphasis"><em>_stat=0</em></span></p>
<p>如果是重新relocate代码之后，就是我们定义的值了，即，在</p>
<p><code class="filename">u-boot-1.1.6_20100601\opt\EmbedSky\u-boot-1.1.6\board\EmbedSky\config.mk</code></p>
<p>中的：</p>
<p>TEXT_BASE = 0x33D00000</p>
<p>表示是代码段的基地址，即</p>
<p><span class="emphasis"><em>_start=TEXT_BASE=0x33D00000</em></span></p>
<p></p>
<p>关于标号的语法解释:</p>
<div class="blockquote"><blockquote class="blockquote">
<p><a class="ulink" href="http://sourceware.org/binutils/docs-2.20/as/Labels.html#Labels" target="_top">http://sourceware.org/binutils/docs-2.20/as/Labels.html#Labels</a></p>
<p>A label is written as a symbol immediately followed by a colon `:'. The symbol then represents the current value of the active location counter, and is, for example, a suitable instruction operand. You are warned if you use the same symbol to represent two different locations: the first definition overrides any other definitions. </p>
</blockquote></div>
<p>而_start标号后面的:</p>
<pre class="programlisting">b       reset</pre>
<p>就是跳转到对应的标号为reset的位置。</p>
</td>
</tr></tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="ldr"></a>1.1.3.&nbsp;ldr</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">	ldr<a class="co" name="co.ldr" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.ldr"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>	pc, _undefined_instruction
	ldr	pc, _software_interrupt
	ldr	pc, _prefetch_abort
	ldr	pc, _data_abort
	ldr	pc, _not_used
	ldr	pc, _irq
	ldr	pc, _fiq
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.ldr"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.ldr"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>ldr命令的语法为：</p>
<div class="blockquote"><blockquote class="blockquote">
<p><a class="ulink" href="http://infocenter.arm.com/help/topic/com.arm.doc.dui0206hc/DUI0206HC_rvct_linker_and_utilities_guide.pdf" target="_top">http://infocenter.arm.com/help/topic/com.arm.doc.dui0206hc/DUI0206HC_rvct_linker_and_utilities_guide.pdf</a></p>
<div class="figure">
<a name="fg.ldr_syntax"></a><p class="title"><b>图&nbsp;1.1.&nbsp;LDR指令的语法</b></p>
<div class="figure-contents"><div class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tbody><tr><td align="left"><img src="./Uboot中start.S源码的指令级的详尽解析_files/ldr_syntax.jpg" align="left" alt="LDR指令的语法"></td></tr></tbody></table></div></div>
</div>
<br class="figure-break">
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p><a class="ulink" href="http://wenku.baidu.com/view/f7cc280102020740be1e9bea.html" target="_top">http://wenku.baidu.com/view/f7cc280102020740be1e9bea.html</a></p>
<p>LDR指令的格式为：</p>
<p>LDR{条件} 目的寄存器，&lt;存储器地址&gt;</p>
<p>LDR指令用于从存储器中将一个32位的字数据传送到目的寄存器中。该指令通常用于从存储器中读取32位的字数据到通用寄存器，然后对数据进行处理。当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。该指令在程序设计中比较常用，且寻址方式灵活多样，请读者认真掌握。</p>
<p>指令示例：</p>
<p><span class="emphasis"><em>LDR R0，[R1]</em></span>        ；将存储器地址为R1的字数据读入寄存器R0。</p>
<p><span class="emphasis"><em>LDR R0，[R1，R2]</em></span>    ；将存储器地址为R1+R2的字数据读入寄存器R0。</p>
<p><span class="emphasis"><em>LDR R0，[R1，＃8]</em></span>   ；将存储器地址为R1+8的字数据读入寄存器R0。</p>
<p><span class="emphasis"><em>LDR R0，[R1，R2]！</em></span>  ；将存储器地址为R1+R2的字数据读入寄存器R0,并将新地址R1＋R2写入R1。</p>
<p><span class="emphasis"><em>LDR R0，[R1，＃8]！</em></span> ；将存储器地址为R1+8的字数据读入寄存器R0，并将新地址R1＋8写入R1。</p>
<p><span class="emphasis"><em>LDR  R0，[R1]，R2</em></span>   ；将存储器地址为R1的字数据读入寄存器R0，并将新地址R1＋R2写入R1。</p>
<p><span class="emphasis"><em>LDR  R0，[R1，R2，LSL＃2]！</em></span> ；将存储器地址为R1＋R2×4的字数据读入寄存器R0，并将新地址R1＋R2×4写入R1。</p>
<p><span class="emphasis"><em>LDRR0，[R1]，R2，LSL＃2</em></span>     ；将存储器地址为R1的字数据读入寄存器R0，并将新地址R1＋R2×4写入R1。”</p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p><a class="ulink" href="http://www.pczpg.com/a/2010/0607/11062.html" target="_top">http://www.pczpg.com/a/2010/0607/11062.html</a></p>
<p>ARM是RISC结构，数据从内存到CPU之间的移动只能通过L/S指令来完成，也就是ldr/str指令。 </p>
<p>比如想把数据从内存中某处读取到寄存器中，只能使用ldr </p>
<p>比如： </p>
<p>ldr r0, 0x12345678</p>
<p>就是把0x12345678这个地址中的值存放到r0中。</p>
</blockquote></div>
<p>上面那些ldr的作用，以第一个_undefined_instruction为例，就是将地址为_undefined_instruction中的一个word的值，赋值给pc。</p>
</td>
</tr></tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="dot_word"></a>1.1.4.&nbsp;.word</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">_undefined_instruction:	.word<a class="co" name="co.word" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.word"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> undefined_instruction
_software_interrupt:	.word software_interrupt
_prefetch_abort:	.word prefetch_abort
_data_abort:		.word data_abort
_not_used:		.word not_used
_irq:			.word irq
_fiq:			.word fiq
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.word"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.word"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<div class="blockquote"><blockquote class="blockquote">
<p><a class="ulink" href="http://blogold.chinaunix.net/u3/115924/showart_2280163.html" target="_top">http://blogold.chinaunix.net/u3/115924/showart_2280163.html</a></p>
<p>.word      .word expr {,expr}…  分配一段字内存单元，并用expr初始化字内存单元(32bit)</p>
</blockquote></div>
<p><a class="ulink" href="http://re-eject.gbadev.org/files/GasARMRef.pdf" target="_top">http://re-eject.gbadev.org/files/GasARMRef.pdf</a></p>
<div class="blockquote"><blockquote class="blockquote">
<div class="table">
<a name="tbl.dot_word_syntax"></a><p class="title"><b>表&nbsp;1.2.&nbsp;.word的语法</b></p>
<div class="table-contents"><table summary=".word的语法" style="border-collapse: collapse;border-top: 1.5pt solid black; border-bottom: 1.5pt solid black; border-left: 1.5pt solid black; border-right: 1.5pt solid black; ">
<colgroup>
<col class="col1">
<col class="col2">
<col class="col3">
<col class="col4">
</colgroup>
<thead><tr>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Directive</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Description</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Syntax</th>
<th style="border-bottom: 0.5pt solid green; ">Example</th>
</tr></thead>
<tbody><tr>
<td style="border-right: 0.5pt solid green; "><span class="emphasis"><em>.word</em></span></td>
<td style="border-right: 0.5pt solid green; ">Define word <span class="emphasis"><em>expr</em></span> (32bit numbers)</td>
<td style="border-right: 0.5pt solid green; ">.word expr {, …}</td>
<td style="">
<span class="emphasis"><em>.word</em></span> 144511, 0x11223</td>
</tr></tbody>
</table></div>
</div>
<br class="table-break">
</blockquote></div>
<p>所以上面的含义，以_undefined_instruction为例，就是，此处分配了一个word=32bit=4字节的地址空间，里面存放的值是undefined_instruction。</p>
<p>而此处_undefined_instruction也就是该地址空间的地址了。用C语言来表达就是：</p>
<p>_undefined_instruction = &amp;undefined_instruction</p>
<p>或</p>
<p>*_undefined_instruction = undefined_instruction</p>
<p>在后面的代码，我们可以看到，undefined_instruction也是一个标号，即一个地址值，对应着就是在发生“未定义指令”的时候，系统所要去执行的代码。</p>
<p>（其他几个对应的“软件中断”，“预取指错误”，“数据错误”，“未定义”，“（普通）中断”，“快速中断”，也是同样的做法，跳转到对应的位置执行对应的代码。）</p>
<p>所以：</p>
<pre class="programlisting">ldr pc, 标号1
......
标号1：.word 标号2
......
标号2：
......（具体要执行的代码）
                </pre>
<p>的意思就是，将地址为标号1中内容载入到pc，而地址为标号1中的内容，正好装的是标号2。</p>
<p>用C语言表达其实很简单：</p>
<p>PC = *（标号1） = 标号2</p>
<p>对PC赋值，即是实现代码跳转，所以整个这段汇编代码的意思就是：</p>
<p><span class="emphasis"><em>跳转到标号2的位置，执行对应的代码。</em></span></p>
</td>
</tr></tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="dot_balignl"></a>1.1.5.&nbsp;.balignl</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">	.balignl<a class="co" name="co.balignl" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.word"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> 16,0xdeadbeef
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.balignl"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.balignl"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>balignl这个标号的语法及含义：</p>
<div class="blockquote"><blockquote class="blockquote">
<p><a class="ulink" href="http://re-eject.gbadev.org/files/GasARMRef.pdf" target="_top">http://re-eject.gbadev.org/files/GasARMRef.pdf</a></p>
<div class="table">
<a name="tbl.balignl_syntax"></a><p class="title"><b>表&nbsp;1.3.&nbsp;balignl的语法</b></p>
<div class="table-contents"><table summary="balignl的语法" style="border-collapse: collapse;border-top: 1.5pt solid black; border-bottom: 1.5pt solid black; border-left: 1.5pt solid black; border-right: 1.5pt solid black; ">
<colgroup>
<col class="col1">
<col class="col2">
<col class="col3">
<col class="col4">
</colgroup>
<thead><tr>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Directive</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Description</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Syntax</th>
<th style="border-bottom: 0.5pt solid green; ">Example</th>
</tr></thead>
<tbody><tr>
<td style="border-right: 0.5pt solid green; "><span class="emphasis"><em>.balignl</em></span></td>
<td style="border-right: 0.5pt solid green; ">Word align the following code to <span class="emphasis"><em>alignment</em></span> byte boundary (<span class="emphasis"><em>default=4</em></span>). Fill skipped words with <span class="emphasis"><em>fill</em></span> (<span class="emphasis"><em>default=0 or NOP</em></span>). If the number of bytes skipped is greater than max, then don't align (<span class="emphasis"><em>default=alignment</em></span> ).</td>
<td style="border-right: 0.5pt solid green; ">.balignl {alignment} {, fill} {, max}</td>
<td style=""><span class="emphasis"><em>.balignl</em></span></td>
</tr></tbody>
</table></div>
</div>
<br class="table-break">
</blockquote></div>
<p>所以意思就是，接下来的代码，都要16字节对齐，不足之处，用0xdeadbeef填充。</p>
<p>其中关于所要填充的内容0xdeadbeef，刚开始没看懂是啥意思，后来终于搞懂了。</p>
<p>经过（<code class="email">&lt;<a class="email" href="mailto:645116977@qq.com">645116977@qq.com</a>&gt;</code>等）多位网友提示和纠正，觉得这样解释会更加合理些：</p>
<p>此处0xdeadbeef本身没有真正的意义，但是很明显，字面上的意思是，（坏）死的牛肉。</p>
<p>虽然其本身没有实际意义，但是其是在十六进制下，能表示出来的，为数不多的，可读的单词之一了。</p>
<p>另外一个相对常见的是：<span class="emphasis"><em>0xbadc0de</em></span>，意思是bad code，坏的代码，注意其中的o是0，因为十六进制中是没有o的。</p>
<p>这些“单词”，相对的作用是，使得读代码的人，以及在查看程序运行结果时，容易看懂，便于引起注意。</p>
<p>而关于自己之前，随意杜撰出来的，希望起到搞笑作用，表示good beef（好的牛肉）的0xgoodbeef，实际上，在十六进制下，会出错的，因为十六进制下没有o和
                g这两个字母。</p>
</td>
</tr></tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="_text_base__armboot_start"></a>1.1.6.&nbsp;_TEXT_BASE _armboot_start</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">/*
 *************************************************************************
 *
 * Startup Code (reset vector)
 *
 * do important init only if we don't start from memory!
 * relocate armboot to ram
 * setup stack
 * jump to second stage
 *
 *************************************************************************
 */

_TEXT_BASE<a class="co" name="co._text_base" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note._text_base"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>:
	.word	TEXT_BASE

<a class="co" name="co.globl_armboot_start" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.globl_armboot_start"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a>.globl _armboot_start
_armboot_start:
	.word _start
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note._text_base"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co._text_base"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>此处和上面的类似，_TEXT_BASE是一个标号地址，此地址中是一个word类型的变量，变量名是TEXT_BASE,此值见名知意，是text的base，即代码的基地址，可以在</p>
<p><code class="filename">u-boot-1.1.6_20100601\opt\EmbedSky\u-boot-1.1.6\board\EmbedSky\config.mk</code></p>
<p>中找到其定义：</p>
<pre class="programlisting">TEXT_BASE = 0x33D00000</pre>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.globl_armboot_start"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.globl_armboot_start"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>同理，此含义可用C语言表示为：</p>
<p><span class="emphasis"><em>*(_armboot_start) = _start</em></span></p>
</td>
</tr>
</tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="_bss_start__bss_end"></a>1.1.7.&nbsp;_bss_start _bss_end</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">/*
 * These are defined in the board-specific linker script.
 */
.globl _bss_start
_bss_start:
	.word __bss_start
<a class="co" name="co.bss_start_end" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.bss_start_end"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>
.globl _bss_end
_bss_end:
	.word _end
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.bss_start_end"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.bss_start_end"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>关于_bss_start和_bss_end都只是两个标号，对应着此处的地址。</p>
<p>而两个地址里面分别存放的值是__bss_start和_end,这两个的值，根据注释所说，是定义在开发板相关的链接脚本里面的，我们此处的开发板相关的链接脚本是：</p>
<p><code class="filename">u-boot-1.1.6_20100601\opt\EmbedSky\u-boot-1.1.6\board\EmbedSky\u-boot.lds</code></p>
<p>其中可以找到__bss_start和_end的定义：</p>
<pre class="programlisting">	__bss_start = .;
	.bss : { *(.bss) }
	_end = .;
                </pre>
<p>而关于_bss_start和_bss_end定义为.glogl即全局变量，是因为uboot的其他源码中要用到这两个变量，详情请自己去搜索源码。</p>
</td>
</tr></tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="free_ram_end_free_ram_size"></a>1.1.8.&nbsp;FREE_RAM_END FREE_RAM_SIZE</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">.globl FREE_RAM_END
FREE_RAM_END:
	.word	0x0badc0de
<a class="co" name="co.free_ram_start_end" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.free_ram_start_end"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>
.globl FREE_RAM_SIZE
FREE_RAM_SIZE:
	.word	0x0badc0de
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.free_ram_start_end"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.free_ram_start_end"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>关于FREE_RAM_END和FREE_RAM_SIZE，这里只是两个标号，之所以也是声明为全局变量，是因为uboot的源码中会用到这两个变量。</p>
<p>但是这里有点特别的是，这两个变量，将在本源码start.S中的后面要用到，而在后面用到这两个变量之前，uboot的C源码中，会先去修改这两个值，具体的逻辑是：</p>
<p>本文件start.S中，后面有这两句：</p>
<pre class="programlisting">	ldr	pc, _start_armboot

_start_armboot:	.word start_armboot
                </pre>
<p>意思很明显，就是去调用start_armboot函数。</p>
<p>而start_armboot函数是在：</p>
<p><code class="filename">u-boot-1.1.6_20100601\opt\EmbedSky\u-boot-1.1.6\lib_arm\board.c</code></p>
<p>中：</p>
<pre class="programlisting">init_fnc_t *init_sequence[] = {
	cpu_init,		/* basic cpu dependent setup */
......
	NULL,
};

void start_armboot (void)
{
	init_fnc_t **init_fnc_ptr;
......

	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
		if ((*init_fnc_ptr)() != 0) {
			hang ();
		}
	}
......

}
                </pre>
<p>即在start_armboot去调用了cpu_init。</p>
<p>cpu_init函数是在：</p>
<p><code class="filename">u-boot-1.1.6_20100601\opt\EmbedSky\u-boot-1.1.6\cpu\arm920t\cpu.c</code></p>
<p>中：</p>
<p><a name="code_cpu_init"></a><b>cpu_init源码.&nbsp;</b></p>
<pre class="programlisting">int cpu_init (void)
{
    /*
     * setup up stacks if necessary
     */
#ifdef CONFIG_USE_IRQ
    IRQ_STACK_START = _armboot_start - CFG_MALLOC_LEN - CFG_GBL_DATA_SIZE - 4;
    FIQ_STACK_START = IRQ_STACK_START - CONFIG_STACKSIZE_IRQ;
    FREE_RAM_END = FIQ_STACK_START - CONFIG_STACKSIZE_FIQ - CONFIG_STACKSIZE;
    FREE_RAM_SIZE = FREE_RAM_END - PHYS_SDRAM_1;
#else    
    FREE_RAM_END = _armboot_start - CFG_MALLOC_LEN - CFG_GBL_DATA_SIZE - 4 - CONFIG_STACKSIZE;
    FREE_RAM_SIZE = FREE_RAM_END - PHYS_SDRAM_1;
#endif
    return 0;
}
                    </pre>
<p>在cpu_init中，根据我们的一些定义，比如堆栈大小等等，去修改了IRQ_STACK_START ，FIQ_STACK_START ，FREE_RAM_END和FREE_RAM_SIZE的值。</p>
<p>至于为何这么修改，后面遇到的时候会具体再解释。</p>
</td>
</tr></tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="irq_stack_start_fiq_stack_start"></a>1.1.9.&nbsp;IRQ_STACK_START FIQ_STACK_START</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">#ifdef CONFIG_USE_IRQ
/* IRQ stack memory (calculated at run-time) */
.globl IRQ_STACK_START
IRQ_STACK_START:
	.word	0x0badc0de
<a class="co" name="co.irq_fiq_stack_start" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.irq_fiq_stack_start"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>
/* IRQ stack memory (calculated at run-time) */
.globl FIQ_STACK_START
FIQ_STACK_START:
	.word 0x0badc0de
#endif
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.irq_fiq_stack_start"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.irq_fiq_stack_start"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>同上，IRQ_STACK_START和FIQ_STACK_START，也是在cpu_init中用到了。</p>
<p>不过此处，是只有当定义了宏CONFIG_USE_IRQ的时候，才用到这两个变量，其含义也很明显，</p>
<p>只有用到了中断IRQ，才会用到中断的堆栈，才有中端堆栈的起始地址。</p>
<p>快速中断FIQ，同理。</p>
</td>
</tr></tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpsr"></a>1.1.10.&nbsp;cpsr</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">/*
 * the actual reset code
 */

reset:
	/*
	 * set the cpu to SVC32 mode
	 */
	mrs<a class="co" name="co.mrs" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.mrs"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>	r0,cpsr<a class="co" name="co.cpsr" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.cpsr"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a>
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.cpsr"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.cpsr"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>CPSR 是当前的程序状态寄存器(Current Program Status Register)，</p>
<p>而 SPSR 是保存的程序状态寄存器(Saved Program Status Register)。</p>
<p>具体细节，可参考：</p>
<div class="blockquote"><blockquote class="blockquote"><a class="ulink" href="http://www.docin.com/p-73665362.html" target="_top">ARM7体系结构</a></blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p><a class="ulink" href="http://www.csie.nctu.edu.tw/~wjtsai/EmbeddedSystemDesign/Ch2-bootloader.pdf" target="_top">http://www.csie.nctu.edu.tw/~wjtsai/EmbeddedSystemDesign/Ch2-bootloader.pdf</a></p>
<div class="figure">
<a name="fg.cpsr_spsr_bit_field"></a><p class="title"><b>图&nbsp;1.2.&nbsp;CPSR/SPSR的位域结构</b></p>
<div class="figure-contents"><div class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tbody><tr><td align="left"><img src="./Uboot中start.S源码的指令级的详尽解析_files/cpsr_spsr_bit_field.png" align="left" alt="CPSR/SPSR的位域结构"></td></tr></tbody></table></div></div>
</div>
<br class="figure-break">
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<div class="table">
<a name="tbl.cpsr_bitfield"></a><p class="title"><b>表&nbsp;1.4.&nbsp;CPSR Bitfield</b></p>
<div class="table-contents"><table summary="CPSR Bitfield" style="border-collapse: collapse;border-top: 1.5pt solid black; border-bottom: 1.5pt solid black; border-left: 1.5pt solid black; border-right: 1.5pt solid black; ">
<colgroup>
<col class="col1">
<col class="col2">
<col class="col3">
<col class="col4">
<col class="col5">
<col class="col6">
<col class="col7">
<col class="col8">
<col class="col9">
<col class="col10">
<col class="col11">
<col class="col12">
<col class="col13">
<col class="col14">
</colgroup>
<thead><tr>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">31</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">30</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">29</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">28</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">---</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">7</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">6</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">-</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">4</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">3</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">2</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</th>
<th style="border-bottom: 0.5pt solid green; ">说明</th>
</tr></thead>
<tbody>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">N</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Z</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">C</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">V</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">&nbsp;</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">I</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">F</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">&nbsp;</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">M4</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">M3</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">M2</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">M1</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">M0</td>
<td style="border-bottom: 0.5pt solid green; ">&nbsp;</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; " colspan="8" align="center">&nbsp;</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-bottom: 0.5pt solid green; ">User26 模式</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; " colspan="8" align="center">&nbsp;</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-bottom: 0.5pt solid green; ">FIQ26 模式</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; " colspan="8" align="center">&nbsp;</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-bottom: 0.5pt solid green; ">IRQ26 模式</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; " colspan="8" align="center">&nbsp;</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-bottom: 0.5pt solid green; ">SVC26 模式</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; " colspan="8" align="center">&nbsp;</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-bottom: 0.5pt solid green; ">User 模式</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; " colspan="8" align="center">&nbsp;</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-bottom: 0.5pt solid green; ">FIQ 模式</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; " colspan="8" align="center">&nbsp;</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-bottom: 0.5pt solid green; ">IRQ 模式</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; " colspan="8" align="center">&nbsp;</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-bottom: 0.5pt solid green; ">SVC 模式</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; " colspan="8" align="center">&nbsp;</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-bottom: 0.5pt solid green; ">ABT 模式</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; " colspan="8" align="center">&nbsp;</td>
<td style="border-right: 0.5pt solid green; ">1</td>
<td style="border-right: 0.5pt solid green; ">1</td>
<td style="border-right: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; ">1</td>
<td style="border-right: 0.5pt solid green; ">1</td>
<td style="">UND 模式</td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break">
</blockquote></div>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.mrs"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.mrs"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>MRS - Move From Status Register</p>
<p>MRS指令的语法为：</p>
<div class="blockquote"><blockquote class="blockquote">
<p>四、程序状态寄存器访问指令</p>
<p>1、  MRS指令</p>
<p>MRS指令的格式为：</p>
<p>MRS{条件}    通用寄存器，程序状态寄存器（CPSR或SPSR）</p>
<p>MRS指令用于将程序状态寄存器的内容传送到通用寄存器中。该指令一般用在以下两种情况：</p>
<p>Ⅰ.当需要改变程序状态寄存器的内容时，可用MRS将程序状态寄存器的内容读入通用寄存器，修改后再写回程序状态寄存器。</p>
<p>Ⅱ.当在异常处理或进程切换时，需要保存程序状态寄存器的值，可先用该指令读出程序状态寄存器的值，然后保存。</p>
<p>指令示例：</p>
<p>MRS R0，CPSR                         ；传送CPSR的内容到R0</p>
<p>MRS R0，SPSR                         ；传送SPSR的内容到R0”</p>
</blockquote></div>
<p>所以，上述汇编代码含义为，将CPSR的值赋给R0寄存器。</p>
</td>
</tr>
</tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="bic"></a>1.1.11.&nbsp;bic</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">	bic<a class="co" name="co.bic" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.bic"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>	r0,r0,#0x1f
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.bic"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.bic"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>bic指令的语法是：</p>
<div class="blockquote"><blockquote class="blockquote">
<p>16、BIC指令</p>
<p>BIC指令的格式为：</p>
<p>BIC{条件}{S} 目的寄存器，操作数1，操作数2</p>
<p>BIC指令用于清除操作数1的某些位，并把结果放置到目的寄存器中。操作数1应是一个寄存器，</p>
<p>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。操作数2为32位的掩码，如果在掩码中设置了某一位，则清除这一位。未设置的掩码位保持不变。</p>
</blockquote></div>
<p>而0x1f=11111b</p>
<p>所以，此行代码的含义就是，清除r0的bit[4:0]位。</p>
</td>
</tr></tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="orr"></a>1.1.12.&nbsp;orr</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">	orr<a class="co" name="co.orr" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.orr"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>	r0,r0,#0xd3
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.orr"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.orr"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>orr指令的语法是：</p>
<div class="blockquote"><blockquote class="blockquote">
<p>14、ORR指令</p>
<p>ORR指令的格式为：</p>
<p>ORR{条件}{S} 目的寄存器，操作数1，操作数2</p>
<p>ORR指令用于在两个操作数上进行逻辑或运算，并把结果放置到目的寄存器中。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。该指令常用于设置操作数1的某些位。</p>
<p>指令示例：</p>
<p>ORR R0，R0，＃3         ； 该指令设置R0的0、1位，其余位保持不变。</p>
</blockquote></div>
<p>所以此行汇编代码的含义为：</p>
<p>而0xd3=1101 0111[4:0]位。</p>
<p>将r0与0xd3算数或运算，然后将结果给r0,即把r0的bit[7:6]和bit[4]和bit[2:0]置为1。</p>
</td>
</tr></tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="msr"></a>1.1.13.&nbsp;msr</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">	msr<a class="co" name="co.msr" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.msr"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>	cpsr,r0
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.msr"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.msr"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>MSR - Move to Status Register</p>
<p>msr的指令格式是：</p>
<div class="blockquote"><blockquote class="blockquote">
<p>四、程序状态寄存器访问指令</p>
<p>......</p>
<p>2、  MSR指令</p>
<p>MSR指令的格式为：</p>
<p>MSR{条件}    程序状态寄存器（CPSR或SPSR）_&lt;域&gt;，操作数</p>
<p>MSR指令用于将操作数的内容传送到程序状态寄存器的特定域中。其中，操作数可以为通用寄存器或立即数。&lt;域&gt;用于设置程序状态寄存器中需要操作的位，32位的程序状态寄存器可分为4个域：</p>
<p>位[31：24]为条件标志位域，用f表示；</p>
<p>位[23：16]为状态位域，用s表示；</p>
<p>位[15：8]为扩展位域，用x表示；</p>
<p>位[7：0]为控制位域，用c表示；</p>
<p>该指令通常用于恢复或改变程序状态寄存器的内容，在使用时，一般要在MSR指令中指明将要操作的域。</p>
<p>指令示例：</p>
<p>MSR CPSR，R0        ；传送R0的内容到CPSR</p>
<p>MSR SPSR，R0        ；传送R0的内容到SPSR</p>
<p>MSR CPSR_c，R0      ；传送R0的内容到SPSR，但仅仅修改CPSR中的控制位域</p>
</blockquote></div>
<p>此行汇编代码含义为，将r0的值赋给CPSR。</p>
</td>
</tr></tbody></table></div>
</div>
</div>
<p>所以，上面四行汇编代码的含义就很清楚了。</p>
<p>先是把CPSR的值放到r0寄存器中，然后清除bit[4:0]，然后再或上</p>
<pre class="screen">0xd3=11   0  10111b</pre>
<p></p>
<div class="table">
<a name="tbl.cpsr_0xd3_bitfields"></a><p class="title"><b>表&nbsp;1.5.&nbsp;CPSR=0xD3的位域及含义</b></p>
<div class="table-contents"><table summary="CPSR=0xD3的位域及含义" style="border-collapse: collapse;border-top: 1.5pt solid black; border-bottom: 1.5pt solid black; border-left: 1.5pt solid black; border-right: 1.5pt solid black; ">
<colgroup>
<col class="col1">
<col class="col2">
<col class="col3">
<col class="col4">
<col class="col5">
<col class="col6">
<col class="col7">
<col class="col8">
<col class="col9">
</colgroup>
<tbody>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">CPSR位域</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">7</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">6</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">5</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">4</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">3</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">2</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-bottom: 0.5pt solid green; ">0</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">位域含义</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">I</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">F</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">&nbsp;</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">M4</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">M3</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">M2</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">M1</td>
<td style="border-bottom: 0.5pt solid green; ">M0</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0xD3</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-bottom: 0.5pt solid green; ">1</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; ">对应含义</td>
<td style="border-right: 0.5pt solid green; ">关闭中断IRQ</td>
<td style="border-right: 0.5pt solid green; ">关闭快速中断FIQ</td>
<td style="border-right: 0.5pt solid green; ">&nbsp;</td>
<td style="" colspan="5" align="center">设置CPU为SVC模式,这和上面代码注释中的“set the cpu to SVC32 mode”，也是一致的。</td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>关于为何设置CPU为SVC模式，而不是设置为其他模式，请参见本文档后面的章节：<a class="xref" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#why_svc_not_other" title="3.2. uboot初始化中，为何要设置CPU为SVC模式而不是设置为其他模式">第&nbsp;3.2&nbsp;节 “uboot初始化中，为何要设置CPU为SVC模式而不是设置为其他模式”</a></p>
</div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="ch01s2_close_watchdog"></a>1.2.&nbsp;关闭看门狗</h2></div></div></div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="pwtcon_intmod_intmsk_intsubmsk_clkdivn"></a>1.2.1.&nbsp;pWTCON INTMOD INTMSK INTSUBMSK CLKDIVN</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">/* turn off the watchdog */
#if defined(CONFIG_S3C2400)
# define pWTCON		0x15300000
# define INTMSK		0x14400008	/* Interupt-Controller base addresses */
# define CLKDIVN	0x14800014	/* clock divisor register */
#elif defined(CONFIG_S3C2410) || defined(CONFIG_S3C2440)<a class="co" name="co.some_macros" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.some_macros"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>
# define pWTCON		0x53000000
# define INTMOD		0X4A000004
# define INTMSK		0x4A000008	/* Interupt-Controller base addresses */
# define INTSUBMSK	0x4A00001C
# define CLKDIVN	0x4C000014	/* clock divisor register */
#endif
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.some_macros"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.some_macros"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>上面几个宏定义所对应的地址，都可以在对应的datasheet中找到对应的定义：</p>
<p>其中，S3C2410和TQ2440开发板所用的CPU S3C2440，两者在这部分的寄存器定义，都是一样的，所以此处，采用CONFIG_S3C2410所对应的定义。</p>
<p>关于<span class="emphasis"><em>S3C2440相关的软硬件资料</em></span>，这个网站提供的很全面：</p>
<p><a class="ulink" href="http://just4you.springnote.com/pages/1052612" target="_top">http://just4you.springnote.com/pages/1052612</a></p>
<p>其中有S3C2440的CPU的datasheet：</p>
<p><a class="ulink" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/s3c2440a_um_rev014_040712.pdf" target="_top">s3c2440a_um_rev014_040712.pdf</a></p>
<p>其中有对应的寄存器定义： </p>
<div class="figure">
<a name="fg.pwtcon"></a><p class="title"><b>图&nbsp;1.3.&nbsp;pWTCON</b></p>
<div class="figure-contents"><div class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tbody><tr><td align="left"><img src="./Uboot中start.S源码的指令级的详尽解析_files/pwtcon.png" align="left" alt="pWTCON"></td></tr></tbody></table></div></div>
</div>
<br class="figure-break"><div class="figure">
<a name="fg.intmod"></a><p class="title"><b>图&nbsp;1.4.&nbsp;INTMOD</b></p>
<div class="figure-contents"><div class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tbody><tr><td align="left"><img src="./Uboot中start.S源码的指令级的详尽解析_files/intmod.png" align="left" alt="INTMOD"></td></tr></tbody></table></div></div>
</div>
<br class="figure-break"><div class="figure">
<a name="fg.intmsk"></a><p class="title"><b>图&nbsp;1.5.&nbsp;INTMSK</b></p>
<div class="figure-contents"><div class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tbody><tr><td align="left"><img src="./Uboot中start.S源码的指令级的详尽解析_files/intmsk.png" align="left" alt="INTMSK"></td></tr></tbody></table></div></div>
</div>
<br class="figure-break"><div class="figure">
<a name="fg.intsubmsk"></a><p class="title"><b>图&nbsp;1.6.&nbsp;INTSUBMSK</b></p>
<div class="figure-contents"><div class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tbody><tr><td align="left"><img src="./Uboot中start.S源码的指令级的详尽解析_files/intsubmsk.png" align="left" alt="INTSUBMSK"></td></tr></tbody></table></div></div>
</div>
<br class="figure-break"><div class="figure">
<a name="fg.clkdivn"></a><p class="title"><b>图&nbsp;1.7.&nbsp;CLKDIVN</b></p>
<div class="figure-contents"><div class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tbody><tr><td align="left"><img src="./Uboot中start.S源码的指令级的详尽解析_files/clkdivn.png" align="left" alt="CLKDIVN"></td></tr></tbody></table></div></div>
</div>
<br class="figure-break"><p>而关于每个寄存器的具体含义，见后面的分析。</p>
</td>
</tr></tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="ldr_pwtcon"></a>1.2.2.&nbsp;ldr pWTCON</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">#if defined(CONFIG_S3C2400) || defined(CONFIG_S3C2410) || defined(CONFIG_S3C2440)
	ldr<a class="co" name="co.ldr_pwtcon" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.ldr_pwtcon"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>     r0, =pWTCON
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.ldr_pwtcon"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.ldr_pwtcon"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>这里的ldr和前面介绍的ldr指令不是一个意思。</p>
<p>这里的ldr是伪指令ldr。</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip: 伪指令">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[提示]" src="./Uboot中start.S源码的指令级的详尽解析_files/tip.png"></td>
<th align="left">伪指令</th>
</tr>
<tr><td align="left" valign="top">
<p>伪指令，就是“伪”的指令，是针对“真”的指令而言的。</p>
<p>真的指令就是那些常见的指令，比如上面说的arm的ldr，bic，msr等等指令，是arm体系架构中真正存在的指令，你在arm汇编指令集中找得到对应的含义。</p>
<p>而伪指令是写出来给汇编程序看的，汇编程序能看的伪指令具体表示的是啥意思，然后将其翻译成真正的指令或者进行相应的处理。</p>
<p>伪指令ldr语法和含义：</p>
<div class="blockquote"><blockquote class="blockquote">
<p><a class="ulink" href="http://blog.csdn.net/lihaoweiV/archive/2010/11/24/6033003.aspx%20" target="_top">http://blog.csdn.net/lihaoweiV/archive/2010/11/24/6033003.aspx </a></p>
<p>另外还有一个就是ldr伪指令，虽然ldr伪指令和ARM的ldr指令很像，但是作用不太一样。ldr伪指令可以在立即数前加上=，以表示把一个地址写到某寄存器中，比如： </p>
<p>ldr r0, =0x12345678</p>
<p>这样，就把0x12345678这个地址写到r0中了。所以，ldr伪指令和mov是比较相似的。</p>
</blockquote></div>
<p>只不过mov指令后面的立即数是有限制的，这个立即数，能够<span class="emphasis"><em>必须由一个8位的二进制数，即属于0x00-0xFF内的某个值，经过偶数次右移后得到，这样才是合法数据</em></span>，而ldr伪指令没有这个限制。</p>
<p>那为何ldr伪指令的操作数没有限制呢，那是因为其是伪指令，写出来的伪指令，最终会被编译器解释成为真正的，合法的指令的，一般都是对应的mov指令。</p>
<p>这样的话，写汇编程序的时候，使用MOV指令是比较麻烦的，因为有些简单的数据比较容易看出来，有些数据即不容易看出来是否是合法数据。所以，对此，ldr伪指令的出现，就是为了解决这个问题的，你只管放心用ldr伪指令，不用关心操作数，而写出的ldr伪指令，编译器会帮你翻译成对应的真正的汇编指令的。</p>
<p>而关于编译器是如何将这些ldr伪指令翻译成为真正的汇编指令的，我的理解是，其自动会去算出来对应的操作数，是否是合法的mov 的操作数，如果是，就将该ldr伪指令翻译成mov指令，否则就用别的方式处理，我所观察到的，其中一种方式就是，单独申请一个4字节的空间用于存放操作数，然后用ldr指令实现。</p>
<p>在uboot中，最后make完毕之后，会生产u-boot,</p>
<p>通过:</p>
<pre class="screen">arm-linux-objdump –d u-boot &gt; dump_u-boot.txt</pre>
<p>就可以把对应的汇编代码输出到该txt文件了，其中就能找到伪指令：</p>
<pre class="screen">ldr     r0, =0x53000000</pre>
<p>所对应的，真正的汇编代码：</p>
<pre class="screen">33d00068:	e3a00453 	mov	r0, #1392508928	; 0x53000000</pre>
<p>所以被翻译成了mov指令。</p>
<p>而经过我的尝试，故意将0x53000000改为0x53000010，对应的生产的汇编代码为：</p>
<pre class="screen">33d00068:	e59f0408 	ldr	r0, [pc, #1032]	; 33d00478 &lt;fiq+0x58&gt;
......
33d00478:	53000010 	.word	0x53000010
                    </pre>
<p>其中可以看到，由于0x53000010不是有效的mov的操作数，没法找到合适的0x00-0Xff去通过偶数次循环右移而得到，所以只能换成此处这种方式，即在另外申请一个word的空间用于存放这个值：</p>
<pre class="screen">33d00478:	53000010 	.word	0x53000010</pre>
<p>然后通过计算出相对当前PC的偏移，得到的地址，用ldr指令去除该地址中的值，即0x53000010，送给r0,比起mov指令，要复杂的多，也多消耗了一个word的空间。</p>
<p>对应地，其他的方式，个人理解，好像也可以通过MVN指令来实现，具体细节，有待进一步探索。</p>
</td></tr>
</tbody></table></div>
<p>而这里的：</p>
<pre class="programlisting">ldr     r0, =pWTCON</pre>
<p>意思就很清楚了，就是把宏pWTCON的值赋值给r0寄存器，即</p>
<p><span class="emphasis"><em>r0=0x53000000</em></span></p>
</td>
</tr></tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="mov"></a>1.2.3.&nbsp;mov</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">	mov<a class="co" name="co.mov" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.mov"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>     r1, #0x0
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.mov"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.mov"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>mov指令语法：</p>
<div class="blockquote"><blockquote class="blockquote">
<p>1、    MOV指令</p>
<p>MOV指令的格式为：</p>
<p>MOV{条件}{S} 目的寄存器，源操作数</p>
<p>MOV指令可完成从另一个寄存器、被移位的寄存器或将一个立即数加载到目的寄存器。其中S选项决定指令的操作是否影响CPSR中条件标志位的值，当没有S时指令不更新CPSR中条件标志位的值。</p>
<p>指令示例：</p>
<p>MOV R1，R0                        ；将寄存器R0的值传送到寄存器R1</p>
<p>MOV PC，R14                       ；将寄存器R14的值传送到PC，常用于子程序返回</p>
<p>MOV R1，R0，LSL＃3                ；将寄存器R0的值左移3位后传送到R1</p>
</blockquote></div>
<p>不过对于MOV指令多说一句，那就是，一般可以用类似于：</p>
<pre class="programlisting">MOV R0，R0</pre>
<p>的指令来实现NOP操作。</p>
<p>上面这句mov指令很简单，就是把0x0赋值给r1，即</p>
<p><span class="emphasis"><em>r1=0x0</em></span></p>
</td>
</tr></tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="str"></a>1.2.4.&nbsp;str</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">	str<a class="co" name="co.str" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.str"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>     r1, [r0]
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.str"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.str"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>str指令语法：</p>
<div class="blockquote"><blockquote class="blockquote">
<p>4、STR指令</p>
<p>STR指令的格式为：</p>
<p>STR{条件} 源寄存器，&lt;存储器地址&gt;</p>
<p>STR指令用于从源寄存器中将一个32位的字数据传送到存储器中。该指令在程序设计中比较常用，且寻址方式灵活多样，使用方式可参考指令LDR。</p>
<p>指令示例：</p>
<p>STR R0，[R1]，＃8            ；将R0中的字数据写入以R1为地址的存储器中，并</p>
<p>                                 将新地址R1＋8写入R1。</p>
<p>STR R0，[R1，＃8]            ；将R0中的字数据写入以R1＋8为地址的存储器中。</p>
</blockquote></div>
<p>所以这句str的作用也很简单，那就是将r1寄存器的值，传送到地址值为r0的（存储器）内存中。</p>
<p>用C语言表示就是：</p>
<p><span class="emphasis"><em>*r0 = r1</em></span></p>
</td>
</tr></tbody></table></div>
</div>
</div>
<p>所以，上面几行代码意思也很清楚：</p>
<p>先是用r0寄存器存pWTCON的值，然后r1=0，再将r1中的0写入到pWTCON中，其实就是</p>
<pre class="screen">pWTCON = 0;</pre>
<p>而pWTCON寄存器的具体含义是什么呢？下面就来了解其详细含义：</p>
<div class="figure">
<a name="fg.wtcon_reg_bits"></a><p class="title"><b>图&nbsp;1.8.&nbsp;WTCON寄存器的位域</b></p>
<div class="figure-contents"><div class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tbody><tr><td align="left"><img src="./Uboot中start.S源码的指令级的详尽解析_files/wtcon_reg_bits.jpg" align="left" alt="WTCON寄存器的位域"></td></tr></tbody></table></div></div>
</div>
<br class="figure-break"><p>注意到bit[0]是Reset Enable/Disable，而设置为0的话，那就是关闭Watchdog的reset了，所以其他位的配置选项，就更不需要看了。</p>
<p>我们只需要了解，<span class="emphasis"><em>在此处禁止了看门狗WatchDog（的复位功能）</em></span>，即可。</p>
<p>关于看门狗的作用，以及为何要在系统初始化的时候关闭看门狗，请参见本文档后面的章节：<a class="xref" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#why_close_wdt" title="3.3. 什么是watchdog + 为何在要系统初始化的时候关闭watchdog">第&nbsp;3.3&nbsp;节 “什么是watchdog + 为何在要系统初始化的时候关闭watchdog”</a></p>
</div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="ch01s3_disable_interrupt"></a>1.3.&nbsp;关闭中断</h2></div></div></div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="set_intmsk"></a>1.3.1.&nbsp;set INTMSK</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">	/*
	 * mask all IRQs by setting all bits in the INTMR - default
	 */
	mov	r1, #0xffffffff
	ldr	r0, =INTMSK
	str	r1, [r0])<a class="co" name="co.set_intmsk" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.set_intmsk"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.set_intmsk"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.set_intmsk"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>上面这几行代码，和前面的很类似，作用很简单，就是将INTMSK寄存器设置为0xffffffff,即，将所有的中端都mask了。</p>
<p>关于每一位的定义，其实可以不看的，反正此处都已mask了，不过还是贴出来，以备后用：</p>
<div class="figure">
<a name="fg.intmsk_reg_bits"></a><p class="title"><b>图&nbsp;1.9.&nbsp;INTMSK寄存器的位域</b></p>
<div class="figure-contents"><div class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tbody><tr><td align="left"><img src="./Uboot中start.S源码的指令级的详尽解析_files/intmsk_reg_bits.png" align="left" alt="INTMSK寄存器的位域"></td></tr></tbody></table></div></div>
</div>
<br class="figure-break"><p>此处，关于mask这个词，解释一下。</p>
<p>mask这个单词，是面具的意思，而中断被mask了，就是中断被掩盖了，即虽然硬件上中断发生了，但是此处被屏蔽了，所以从效果上来说，就相当于中断被禁止了，硬件上即使发生了中断，CPU也不会去执行对应中断服务程序ISR了。</p>
<p>关于中断的内容的详细解释，推荐看这个，解释的很通俗易懂：<a class="ulink" href="http://www.crifan.com/switch_arm9_2410_transplant_arm_interrupt_principle_the_error_interrupt_nesting_how_come_the_interrupt_number/" target="_top">【转】ARM9 2410移植之ARM中断原理, 中断嵌套的误区，中断号的怎么来的</a></p>
</td>
</tr></tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="set_intsubmsk"></a>1.3.2.&nbsp;set INTSUBMSK</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting"># if defined(CONFIG_S3C2410)
	ldr	r1, =0x3ff<a class="co" name="co.intsubmsk_0x3ff" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.intsubmsk_0x3ff"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>
	ldr	r0, =INTSUBMSK
	str	r1, [r0]
# elif defined(CONFIG_S3C2440)
	ldr	r1, =0x7fff<a class="co" name="co.intsubmsk_0x7fff" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.intsubmsk_0x7fff"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a>
	ldr	r0, =INTSUBMSK
	str	r1, [r0]
# endif
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.intsubmsk_0x3ff"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.intsubmsk_0x3ff"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>此处是将2410的INTSUBMSK设置为0x3ff。</p>
<p>后经<a class="ulink" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/hatemath2005@163.com" target="_top">HateMath</a>的提醒后，去查证，的确此处设置的0x3ff，是不严谨的。</p>
<p>因为，根据2410的datasheet中关于INTSUBMSK的解释，bit[10:0]共11位，虽然默认reset的每一位都是1，但是此处对应的mask值，应该是11位全为1=0x7ff。</p>
<p>即写成0x3ff，虽然是可以正常工作的，但是却不够严谨的。</p>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.intsubmsk_0x7fff"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.intsubmsk_0x7fff"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>此处CPU是是S3C2440，所以用到0x7fff这段代码。</p>
<p>其意思也很容易看懂，就是将INTSUBMSK寄存器的值设置为0x7fff。</p>
<p>先贴出对应每一位的含义：</p>
<div class="figure">
<a name="fg.intsubmsk_reg_bits"></a><p class="title"><b>图&nbsp;1.10.&nbsp;INTSUBMSK寄存器的位域</b></p>
<div class="figure-contents"><div class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tbody><tr><td align="left"><img src="./Uboot中start.S源码的指令级的详尽解析_files/intsubmsk_reg_bits.png" align="left" alt="INTSUBMSK寄存器的位域"></td></tr></tbody></table></div></div>
</div>
<br class="figure-break"><p>然后我们再来分析对应的0x7fff是啥含义。</p>
<p>其实也很简单，意思就是：</p>
<p><span class="emphasis"><em>0x7fff = bit[14:0]全是1 = 上表中的全部中断都被屏蔽（mask）。</em></span></p>
</td>
</tr>
</tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="set_clkdivn"></a>1.3.3.&nbsp;set CLKDIVN</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">#if 0
	/* FCLK:HCLK:PCLK = 1:2:4 */
	/* default FCLK is 120 MHz ! */
	ldr	r0, =CLKDIVN<a class="co" name="co.set_clkdivn" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.set_clkdivn"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>
	mov	r1, #3
	str	r1, [r0]
#endif
#endif	/* CONFIG_S3C2400 || CONFIG_S3C2410 || CONFIG_S3C2440 */<a class="co" name="co.endif_cfg_s3c24xx" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.endif_cfg_s3c24xx"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a>
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.set_clkdivn"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.set_clkdivn"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>此处，关于CLKDIVN的具体含义，参见下表：</p>
<div class="figure">
<a name="fg.clkdivn_reg_bits"></a><p class="title"><b>图&nbsp;1.11.&nbsp;INTSUBMSK寄存器的位域</b></p>
<div class="figure-contents"><div class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tbody><tr><td align="left"><img src="./Uboot中start.S源码的指令级的详尽解析_files/clkdivn_reg_bits.png" align="left" alt="INTSUBMSK寄存器的位域"></td></tr></tbody></table></div></div>
</div>
<br class="figure-break"><p>而此处代码被#if 0注释掉了。</p>
<p>
                    </p>
<p>问：为何要注释掉，难道想要使用其默认的值，即HDIVN和PDIVN上电后，默认值Initial State，都是0，对应的含义为，FCLK:HCLK:PCLK = <span class="emphasis"><em>1:1:1</em></span> ???</p>
<p>
                    </p>
<p>答：不是，是因为我们在其他地方会去初始化时钟，去设置对应的CLKDIVN，详情参考后面的代码<a class="xref" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#bl_clock_init" title="1.4.3. bl clock_init">第&nbsp;1.4.3&nbsp;节 “bl clock_init”</a>的部分。</p>
<p>
                </p>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.endif_cfg_s3c24xx"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.endif_cfg_s3c24xx"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a> </p></td>
<td valign="top" align="left"><p>此处是结束上面的#ifdef</p></td>
</tr>
</tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="bl"></a>1.3.4.&nbsp;bl</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">	/*
	 * we do sys-critical inits only at reboot,
	 * not when booting from ram!
	 */
#ifndef CONFIG_SKIP_LOWLEVEL_INIT
	bl<a class="co" name="co.bl" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.bl"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>	cpu_init_crit
#endif
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.bl"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.bl"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>关于bl指令的含义：</p>
<p>b指令，是单纯的跳转指令，即CPU直接跳转到某地址继续执行。</p>
<p>而BL是Branch with Link，带分支的跳转，而Link指的是Link Register，链接寄存器R14，即lr，所以，bl的含义是，除了包含b指令的单纯的跳转功能，在跳转之前，还把r15寄存器=PC=cpu地址，赋值给r14=lr，然后跳转到对应位置，等要做的事情执行完毕之后，再用</p>
<p>mov pc, lr</p>
<p>使得cpu再跳转回来，所以整个逻辑就是调用子程序的意思。</p>
<p>bl的语法为：</p>
<div class="blockquote"><blockquote class="blockquote">
<p>2、  BL指令</p>
<p>BL指令的格式为：</p>
<p>BL{条件} 目标地址</p>
<p>BL 是另一个跳转指令，但跳转之前，会在寄存器R14中保存PC的当前内容，因此，可以通过将R14 的内容重新加载到PC中，来返回到跳转指令之后的那个指令处执行。该指令是实现子程序调用的一个基本但常用的手段。以下指令：</p>
<p>BL   Label  ；当程序无条件跳转到标号Label处执行时，同时将当前的PC值保存到R14中</p>
</blockquote></div>
<p>对于上面的代码来说，意思就很清晰了，就是当没有定义CONFIG_SKIP_LOWLEVEL_INIT的时候，就掉转到cpu_init_crit的位置，而在后面的代码cpu_init_crit中，你可以看到最后一行汇编代码就是</p>
<p>mov pc, lr，</p>
<p>又将PC跳转回来，所以整个的含义就是，调用子程序cpu_init_crit,等cpu_init_crit执行完毕，再返回此处继续执行下面的代码。</p>
<p>于此对应地b指令，就只是单纯的掉转到某处继续执行，而不能再通过mov pc, lr跳转回来了。</p>
</td>
</tr></tbody></table></div>
</div>
</div>
</div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="ch01s4_setup_stack_pointer"></a>1.4.&nbsp;设置堆栈sp指针</h2></div></div></div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="stack_setup"></a>1.4.1.&nbsp;stack_setup</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">	/* Set up the stack						    */
stack_setup:
	ldr	r0, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */<a class="co" name="co.ldr_textbase" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.ldr_textbase"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>
	sub	r0, r0, #CFG_MALLOC_LEN	/* malloc area                      */
	sub	r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo                        */
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.ldr_textbase"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.ldr_textbase"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>此句含义是，把地址为_TEXT_BASE的内存中的内容给r0,即，将所有的中断都mask了。</p>
<p>而查看前面的相关部分的代码，即：</p>
<pre class="programlisting">_TEXT_BASE:
	.word	TEXT_BASE
                </pre>
<p>得知，地址为_TEXT_BASE的内存中的内容，就是</p>
<p><code class="filename">u-boot-1.1.6_20100601\opt\EmbedSky\u-boot-1.1.6\board\EmbedSky\config.mk</code></p>
<p>中的：</p>
<p>TEXT_BASE = 0x33D00000</p>
<p>所以，此处即：</p>
<p><span class="emphasis"><em>r0</em></span></p>
<p><span class="emphasis"><em>= TEXT_BASE </em></span></p>
<p><span class="emphasis"><em>= 0x33D00000</em></span></p>
<p>而关于sub指令：</p>
<div class="blockquote"><blockquote class="blockquote">
<p>SUB : 减法</p>
<p>(Subtraction)</p>
<p>  SUB{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;, &lt;op 2&gt;</p>
<p>                dest = op_1 - op_2</p>
<p>SUB 用操作数 one 减去操作数 two，把结果放置到目的寄存器中。操作数 1 是一个寄存器，操作数 2 可以是一个寄存器，被移位的寄存器，或一个立即值: </p>
<p>  SUB     R0, R1, R2              ; R0 = R1 - R2</p>
<p>  SUB     R0, R1, #256            ; R0 = R1 - 256</p>
<p>  SUB     R0, R2, R3,LSL#1        ; R0 = R2 - (R3 &lt;&lt; 1)</p>
<p>减法可以在有符号和无符号数上进行。</p>
</blockquote></div>
<p>所以对应含义为：</p>
<p>r0 = r0 - #CFG_MALLOC_LEN</p>
<p>r0 = r0 - #CFG_GBL_DATA_SIZE</p>
<p>其中，对应的两个宏的值是：</p>
<p><code class="filename">u-boot-1.1.6_20100601\opt\EmbedSky\u-boot-1.1.6\include\configs\EmbedSky.h</code></p>
<p>中：</p>
<pre class="programlisting">#define CONFIG_64MB_Nand		0		//添加了对64MB Nand Flash支持

/*
 * Size of malloc() pool
 */
#define CFG_MALLOC_LEN				(CFG_ENV_SIZE + 128*1024)
#define CFG_GBL_DATA_SIZE			128	/* size in bytes reserved for initial data */

#if(CONFIG_64MB_Nand == 1)
#define CFG_ENV_SIZE			0xc000	/* Total Size of Environment Sector */
#else
#define CFG_ENV_SIZE			0x20000	/* Total Size of Environment Sector */
#endif
                </pre>
<p>所以，从源码中的宏定义中可以看出，</p>
<p>CFG_MALLOC_LEN</p>
<p>= (CFG_ENV_SIZE + 128*1024) </p>
<p>= 0x20000 + 128*1024</p>
<p>= 0x40000</p>
<p>= 256*1024</p>
<p>= 256KB</p>
<p></p>
<p>CFG_GBL_DATA_SIZE</p>
<p>= 128</p>
<p>所以，此三行的含义就是算出r0的值：</p>
<p><span class="emphasis"><em>r0</em></span></p>
<p>= (r0 - #CFG_MALLOC_LEN) - #CFG_GBL_DATA_SIZE</p>
<p>= r0 - 0x40000 – 128</p>
<p><span class="emphasis"><em>= r0 – 0x40080</em></span></p>
<p><span class="emphasis"><em>= 33CBFF80</em></span></p>
</td>
</tr></tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="calc_stack"></a>1.4.2.&nbsp;calc stack</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">#ifdef CONFIG_USE_IRQ
	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)<a class="co" name="co.calc_stack" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.calc_stack"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>
#endif
	sub	sp, r0, #12<a class="co" name="co.reduce_12bytes" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.reduce_12bytes"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a>		/* leave 3 words for abort-stack    */
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.calc_stack"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.calc_stack"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>如果定义了CONFIG_USE_IRQ，即如果使用中断的话，那么再把r0的值减去IRQ和FIQ的堆栈的值，</p>
<p>而对应的宏的值也是在</p>
<p><code class="filename">u-boot-1.1.6_20100601\opt\EmbedSky\u-boot-1.1.6\include\configs\EmbedSky.h</code></p>
<p>中：</p>
<pre class="programlisting">/*-------------------------------------------------------------------
 * Stack sizes
 *
 * The stack sizes are set up in start.S using the settings below
 */
#define CONFIG_STACKSIZE		(128*1024)	/* regular stack */
#ifdef CONFIG_USE_IRQ
#define CONFIG_STACKSIZE_IRQ		(4*1024)	/* IRQ stack */
#define CONFIG_STACKSIZE_FIQ		(4*1024)	/* FIQ stack */
#endif
                </pre>
<p>所以，此时r0的值就是：</p>
<p>#ifdef CONFIG_USE_IRQ</p>
<p><span class="emphasis"><em>r0</em></span></p>
<p>= r0 - #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)</p>
<p>= r0 – (4*1024 + 4*1024)</p>
<p>= r0 – 8*1024</p>
<p>= 33CBFF80 – 8*1024</p>
<p><span class="emphasis"><em>= 33CBDF80</em></span></p>
<p>#endif</p>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.reduce_12bytes"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.reduce_12bytes"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>最后，再减去终止异常所用到的堆栈大小，即12个字节。</p>
<p>现在r0的值为：</p>
<p>#ifdef CONFIG_USE_IRQ</p>
<p><span class="emphasis"><em>r0</em></span></p>
<p>= r0 – 12</p>
<p>= 33CBDF80 - 12</p>
<p><span class="emphasis"><em>= 33CBDF74</em></span></p>
<p>#else</p>
<p><span class="emphasis"><em>r0</em></span></p>
<p>= r0 – 12</p>
<p>= 33CBFF80 - 12</p>
<p><span class="emphasis"><em>= 33CBFF74</em></span></p>
<p>#endif</p>
<p>然后将r0的值赋值给sp,即堆栈指针。</p>
<p>关于：</p>
<p>sp代表stack pointer，堆栈指针；</p>
<p>和后面要提到的ip寄存器：</p>
<p>ip代表instruction pointer，指令指针。</p>
<p>更多详情参见下面的解释。</p>
<p>关于ARM的寄存器的别名和相关的APCS，参见本文后面的内容：<a class="xref" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#arm_reg_name_apcs" title="3.5. AMR寄存器的别名 + APCS">第&nbsp;3.5&nbsp;节 “AMR寄存器的别名 + APCS”</a></p>
</td>
</tr>
</tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="bl_clock_init"></a>1.4.3.&nbsp;bl clock_init</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">	bl clock_init<a class="co" name="co.clock_init" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.clock_init"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.clock_init"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.clock_init"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>在上面，经过计算，算出了堆栈的地址，然后赋值给了sp，此处，接着才去调用函数clock_init去初始化时钟。</p>
<p>其中此函数是在C文件：</p>
<p><code class="filename">u-boot-1.1.6_20100601\opt\EmbedSky\u-boot-1.1.6\board\EmbedSky\boot_init.c</code></p>
<p>中：</p>
<pre class="programlisting">void clock_init(void)
{
...设置系统时钟clock的相关代码...
}
                </pre>
<p>看到这里，让我想起，关于其他人的关于此start.S代码解释中说到的，此处是先去设置好堆栈，即初始化sp指针，然后才去调用C语言的函数clock_init的。</p>
<p>而我们可以看到，前面那行代码：</p>
<pre class="programlisting">#ifndef CONFIG_SKIP_LOWLEVEL_INIT
	bl	cpu_init_crit
#endif
                </pre>
<p>就不需要先设置好堆栈，再去进行函数调用。</p>
<p>其中cpu_init_crit对应的代码也在start.S中（详见后面对应部分的代码），是用汇编实现的。</p>
<p>而对于C语言，为何就需要堆栈，而汇编却不需要堆栈的原因，请参见本文后面的内容：<a class="xref" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#why_c_need_stack" title="3.6. 为何C语言（的函数调用）需要堆栈，而汇编语言却不需要堆栈">第&nbsp;3.6&nbsp;节 “为何C语言（的函数调用）需要堆栈，而汇编语言却不需要堆栈”</a></p>
</td>
</tr></tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="adr"></a>1.4.4.&nbsp;adr</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">#ifndef CONFIG_SKIP_RELOCATE_UBOOT
relocate:				/* relocate U-Boot to RAM	    */
	adr<a class="co" name="co.adr" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.adr"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>	r0, _start		/* r0 &lt;- current position of code   */
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.adr"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.adr"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>adr指令的语法和含义：</p>
<div class="blockquote"><blockquote class="blockquote">
<p><a class="ulink" href="http://blog.mcuol.com/User/cdkfGao/article/8057_1.htm" target="_top">http://blog.mcuol.com/User/cdkfGao/article/8057_1.htm</a></p>
<p>1、ADR伪指令--- 小范围的地址读取</p>
<p>     ADR伪指令将基于PC相对偏移的地址值或基于寄存器相对偏移的地址值读取到寄存器中。</p>
<p>在汇编编译器编译源程序时，ADR伪指令被编译器替换成一条合适的指令。通常，编译器用一条ADD指令或SUB指令来实现该ADR伪指令的功能，若不能用一条指令实现，则产生错误，编译失败。</p>
<p>ADR伪指令格式 ：<span class="emphasis"><em>ADR{cond}   register, expr</em></span></p>
<p>地址表达式expr的取值范围：</p>
<p>    当地址值是字节对齐时，其取指范围为: +255  ～ 255B； </p>
<p>    当地址值是字对齐时，其取指范围为:   -1020 ～ 1020B；</p>
</blockquote></div>
<p>所以，上述:</p>
<pre class="programlisting">adr r0, _start</pre>
<p>的意思其实很简单，就是将_start的地址赋值给r0.但是具体实现的方式就有点复杂了，对于用adr指令实现的话，说明_start这个地址，相对当前PC的偏移，应该是很小的，意思就是向前一段后者向后一段去找，肯定能找到_start这个标号地址的，此处，自己通过看代码也可以看到_start，就是在当前指令的前面，距离很近，编译后，对应汇编代码，也可以猜得出，应该是上面所说的，用sub来实现，即当前PC减去某个值，得到_start的值，</p>
<p>参照前面介绍的内容，去：</p>
<pre class="screen">arm-inux-objdump –d u-boot &gt; dump_u-boot.txt</pre>
<p>然后打开dump_u-boot.txt,可以找到对应的汇编代码，如下：</p>
<pre class="screen">33d00000 &lt;_start&gt;:
33d00000:	ea000014 	b	33d00058 &lt;reset&gt;
。。。
33d000a4 &lt;relocate&gt;:
33d000a4:	e24f00ac 	sub	r0, pc, #172	; 0xac
                </pre>
<p>可以看到，这个相对当前PC的距离是0xac=172,细心的读者可以看到，那条指令的地址减去0xac，却并不等于_start的值，即</p>
<p>33d000a4 - 33d00000 = 0xa4 != 0xac</p>
<p>而0xac – 0xa4 = 8，</p>
<p>那是因为，由于ARM920T的五级流水线的缘故导致指令执行那一时刻的PC的值等于该条指令PC的值加上8，即</p>
<p>sub	r0, pc, #172中的PC的值是</p>
<p>sub	r0, pc, #172</p>
<p>指令地址：33d000a4,再加上8，即33d000a4+8 = 33d000ac，</p>
<p>所以，33d000ac – 0xac，才等于我们看到的33d00000，才是_start的地址。</p>
<p>这个由于流水线导致的PC的值和当前指令地址不同的现象，就是我们常说的，ARM中，PC=PC+8。</p>
<p>对于为何是PC=PC+8，请参见后面的内容：<a class="xref" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#why_arm7_pc_8" title="3.4. 为何ARM7中PC=PC+8">第&nbsp;3.4&nbsp;节 “为何ARM7中PC=PC+8”</a></p>
<p>对于此处为何不直接用mov指令，却使用adr指令，请参见后面内容：<a class="xref" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#why_adr_not_move" title="3.7. 关于为何不直接用mov指令，而非要用adr伪指令">第&nbsp;3.7&nbsp;节 “关于为何不直接用mov指令，而非要用adr伪指令”</a></p>
<p>对于mov指令的操作数的取值范围，请参见后面内容：<a class="xref" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#mov_value_range" title="3.8. mov指令的操作数的取值范围到底是多少">第&nbsp;3.8&nbsp;节 “mov指令的操作数的取值范围到底是多少”</a></p>
</td>
</tr></tbody></table></div>
</div>
<pre class="programlisting">adr	r0, _start</pre>
<p>的伪代码，被翻译成实际汇编代码为：</p>
<pre class="programlisting">33d000a4:	e24f00ac 	sub	r0, pc, #172	; 0xac</pre>
<p>其含义就是，通过计算PC+8-172 ⇒ _start的地址，</p>
<p>而_start的地址，即相对代码段的0地址，是这个地址在运行时刻的值，而当ARM920T加电启动后，，此处是从Nor Flash启动，对应的代码，也是在Nor Flash中，对应的物理地址是0x0,所以，此时_start的值就是0，而不是0x33d00000。</p>
<p>所以，此时：</p>
<p><span class="emphasis"><em>r0 = 0x0</em></span></p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="clear_bss"></a>1.4.5.&nbsp;clear_bss</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">	ldr	r1, _TEXT_BASE<a class="co" name="co.ldr_text_base" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.ldr_text_base"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>		/* test if we run from flash or RAM */
	<a class="co" name="co.cmp_r0_r1" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.cmp_r0_r1"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a>cmp     r0, r1                  /* don't reloc during debug         */
	<a class="co" name="co.beq_clear_css" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.beq_clear_css"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/3.png" alt="3" border="0"></span></a>beq     clear_bss
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.ldr_text_base"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.ldr_text_base"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>这里的_TEXT_BASE的含义，前面已经说过了，那就是：</p>
<div class="blockquote"><blockquote class="blockquote"><pre class="programlisting">_TEXT_BASE:
	.word	TEXT_BASE
                    </pre></blockquote></div>
<p>得知，地址为_TEXT_BASE的内存中的内容，就是</p>
<p><code class="filename">u-boot-1.1.6_20100601\opt\EmbedSky\u-boot-1.1.6\board\EmbedSky\config.mk</code></p>
<p>中的：</p>
<pre class="programlisting">TEXT_BASE = 0x33D00000</pre>
<p>所以，此处就是</p>
<p><span class="emphasis"><em>r1 = 0x33D00000</em></span></p>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.cmp_r0_r1"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.cmp_r0_r1"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>含义很简单，就是比较r0和r1。而</p>
<p><span class="emphasis"><em>r0 = 0x0</em></span></p>
<p><span class="emphasis"><em>r1 = 0x33D00000</em></span></p>
<p>所以不相等</p>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.beq_clear_css"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.beq_clear_css"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/3.png" alt="3" border="0"></span></a> </p></td>
<td valign="top" align="left"><p>因此beq发现两者不相等，就不会去跳转到clear_bss，不会去执行对应的将bss段清零的动作了。</p></td>
</tr>
</tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="_armboot_start"></a>1.4.6.&nbsp;cal armboot size from _armboot_start</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">	<a class="co" name="co.ldr_armboot" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.ldr_armboot"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>ldr	r2, _armboot_start
	ldr	r3, _bss_start
	<a class="co" name="co.sub_armboot" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.sub_armboot"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a>sub	r2, r3, r2		/* r2 &lt;- size of armboot            */
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.ldr_armboot"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.ldr_armboot"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>这两行代码意思也很清楚，分别装载_armboot_start和_bss_start地址中的值，赋值给r2和r3</p>
<p>而_armboot_start和_bss_start的值，前面都已经提到过了，就是：</p>
<pre class="programlisting">.globl _armboot_start
_armboot_start:
	.word _start

.globl _bss_start
_bss_start:
	.word __bss_start
                </pre>
<div class="blockquote"><blockquote class="blockquote"><pre class="programlisting">_TEXT_BASE:
	.word	TEXT_BASE
                    </pre></blockquote></div>
<p>而其中的_start，是我们uboot的代码的最开始的位置，而__bss_start的值，是在</p>
<p><code class="filename">u-boot-1.1.6_20100601\opt\EmbedSky\u-boot-1.1.6\board\EmbedSky\u-boot.lds</code></p>
<p>中的：</p>
<pre class="programlisting">SECTIONS
{
	. = 0x00000000;

	. = ALIGN(4);
	.text      :
...
	. = ALIGN(4);
	.rodata : { *(.rodata) }

	. = ALIGN(4);
	.data : { *(.data) }

...
	. = ALIGN(4);
	__bss_start = .;
	.bss : { *(.bss) }
	_end = .;
}
                </pre>
<p>所以，可以看出，__bss_start的位置，是bss的start开始位置，同时也是text+rodata+data的结束位置，即代码段，只读数据和已初始化的可写的数据的最末尾的位置。</p>
<p>其实我们也可以通过前面的方法，objdump出来，看到对应的值：</p>
<pre class="screen">33d00048 &lt;_bss_start&gt;:
33d00048:	33d339d4 	.word	0x33d339d4
                </pre>
<p>是0x33d339d4。</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="./Uboot中start.S源码的指令级的详尽解析_files/note.png"></td>
<th align="left">注意</th>
</tr>
<tr><td align="left" valign="top">
<p>【总结】</p>
<p><span class="emphasis"><em>r2 = _start       = 0x33d00000</em></span></p>
<p><span class="emphasis"><em>r3 =__bss_start  = 0x33d339d4</em></span></p>
</td></tr>
</tbody></table></div>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.sub_armboot"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.sub_armboot"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>此处的意思就很清楚了，就是r2 = r3-r2，计算出</p>
<p>text + rodata + data</p>
<p>的大小，即整个需要载入的数据量是多少，用于下面的函数去拷贝这么多的数据到对应的内存的位置。</p>
<p>这里的实际的值是</p>
<p><span class="emphasis"><em>r2</em></span></p>
<p>= r3 –r2 </p>
<p>= 0x33d339d4 - 0x33d00000</p>
<p><span class="emphasis"><em>= 0x000339d4</em></span></p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="./Uboot中start.S源码的指令级的详尽解析_files/note.png"></td>
<th align="left">注意</th>
</tr>
<tr><td align="left" valign="top">
<p>【总结】</p>
<p>到此刻位置,假定是从Nor Flash启动的话：</p>
<p><span class="emphasis"><em>r0 = 0x0 = 我们代码此刻所在的位置</em></span></p>
<p><span class="emphasis"><em>r1 = 0x33D00000 = 我们想要把我们的代码放到哪里</em></span></p>
<p><span class="emphasis"><em>r2 = 0x000339d4 = 对应的代码的大小（此处的代码 = text + rodata + data）</em></span></p>
</td></tr>
</tbody></table></div>
</td>
</tr>
</tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="copycode2ram"></a>1.4.7.&nbsp;cal armboot size from CopyCode2Ram</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">#if 1
	<a class="co" name="co.copy_to_ram" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.copy_to_ram"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>bl  CopyCode2Ram		/* r0: source, r1: dest, r2: size */
#else
	add	r2, r0, r2		/* r2 &lt;- source end address         */

copy_loop:
	ldmia	r0!, {r3-r10}		/* copy from source address [r0]    */
	stmia	r1!, {r3-r10}		/* copy to   target address [r1]    */
	cmp	r0, r2			/* until source end addreee [r2]    */
	ble	copy_loop
#endif
#endif	/* CONFIG_SKIP_RELOCATE_UBOOT */
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.copy_to_ram"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.copy_to_ram"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>此处，代码很简单，只是注释掉了原先的那些代码，而单纯的只是去调用CopyCode2Ram这个函数。</p>
<p>CopyCode2Ram函数，前面也提到过了，是在：</p>
<p><code class="filename">u-boot-1.1.6_20100601\opt\EmbedSky\u-boot-1.1.6\board\EmbedSky\boot_init.c</code></p>
<p>中：</p>
<pre class="programlisting">int CopyCode2Ram(unsigned long start_addr, unsigned char *buf, int size)
{
	unsigned int *pdwDest;
	unsigned int *pdwSrc;
	int i;

	if (bBootFrmNORFlash())
	{
		pdwDest = (unsigned int *)buf;
		pdwSrc  = (unsigned int *)start_addr;
		/* 从 NOR Flash启动 */
		for (i = 0; i &lt; size / 4; i++)
		{
			pdwDest[i] = pdwSrc[i];
		}
		return 0;
	}
	else
	{
		/* 初始化NAND Flash */
		nand_init_ll();

		/* 从 NAND Flash启动 */
		if (NF_ReadID() == 0x76 )
			nand_read_ll(buf, start_addr, (size + NAND_BLOCK_MASK)&amp;~(NAND_BLOCK_MASK));
		else
			nand_read_ll_lp(buf, start_addr, (size + NAND_BLOCK_MASK_LP)&amp;~(NAND_BLOCK_MASK_LP));
		return 0;
	}
}
                </pre>
<p>可以看到，其有三个参数，start_addr，*buf和size，这三个参数，分别正好对应着我们刚才所总结的r0,r1和r2.</p>
<p>这些寄存器和参数的对应关系，也是APSC中定义的：</p>
<div class="blockquote"><blockquote class="blockquote">
<p>实际参数</p>
<p>APCS 没有定义记录、数组、和类似的格局。这样语言可以自由的定义如何进行这些活动。但是，如果你自己的实现实际上不符合 APCS 的精神，那么将不允许来自你的编译器的代码与来自其他编译器的代码连接在一起。典型的，使用 C 语言的惯例。 </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem"><span class="emphasis"><em>前4个整数实参(或者更少!)被装载到 a1 - a4</em></span></li>
<li class="listitem">前 4 个浮点实参(或者更少!)被装载到 f0 - f3</li>
<li class="listitem">其他任何实参(如果有的话)存储在内存中，用进入函数时紧接在 sp 的值上面的字来指向。换句话说，其余的参数被压入栈顶。所以要想简单。最好定义接受 4 个或更少的参数的函数</li>
</ul></div>
</blockquote></div>
<p>上面说的a1-a4,就是寄存器r0-r3。</p>
<p>而CopyCode2Ram函数的逻辑也很清晰，就是先去判断是从Nor Flash启动还是从Nand Flash启动，然后决定从哪里拷贝所需要的代码到对应的目标地址中。</p>
</td>
</tr></tbody></table></div>
</div>
</div>
</div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="ch01s5_clear_bss"></a>1.5.&nbsp;清除bss段</h2></div></div></div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="clear_bss_stack"></a>1.5.1.&nbsp;clear_bss</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">clear_bss:<a class="co" name="co._bss_start_end" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note._bss_start_end"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>
	ldr	r0, _bss_start<a class="co" name="co._bss_start" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note._bss_start"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a>		/* find start of bss segment        */
	ldr	r1, _bss_end<a class="co" name="co._bss_end" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note._bss_end"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/3.png" alt="3" border="0"></span></a>		/* stop here                        */
	mov 	r2, #0x00000000		/* clear                            */
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note._bss_start"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co._bss_start"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>此处的_bss_start是：</p>
<pre class="programlisting">.globl _bss_start
_bss_start:
	.word __bss_start
                </pre>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note._bss_end"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co._bss_end"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/3.png" alt="3" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>而_bss_end,是：</p>
<pre class="programlisting">.globl _bss_end
_bss_end:
	.word _end
                </pre>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note._bss_start_end"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co._bss_start_end"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>对应的，__bss_start和_end，都在前面提到过的那个链接脚本里面：</p>
<code class="filename">u-boot-1.1.6_20100601\opt\EmbedSky\u-boot-1.1.6\board\EmbedSky\u-boot.lds</code><p>中的：</p>
<pre class="programlisting">	__bss_start = .;
	.bss : { *(.bss) }
	_end = .;
                </pre>
<p>即bss段的起始地址和结束地址。</p>
</td>
</tr>
</tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="clear_css_loop"></a>1.5.2.&nbsp;clear css loop</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting"><a class="co" name="co.clbss_l" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.clbss_l"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>clbss_l:str	r2, [r0]		/* clear loop...                    */
	add	r0, r0, #4
	cmp	r0, r1
	ble	clbss_l
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.clbss_l"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.clbss_l"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>此段代码含义也很清晰，那就是，</p>
<p>先将r2,即0x0，存到地址为r0的内存中去，然后r0地址加上4，比较r0地址和r1地址，即比较当前地址是否到了bss段的结束位置，如果le，little or equal，小于或等于，那么就跳到clbss_l,即接着这几个步骤，直到地址超过了bss的_end位置，即实现了将整个bss段，都清零。</p>
</td>
</tr></tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="ldr_pc"></a>1.5.3.&nbsp;ldr pc</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">#if 0<a class="co" name="co.omit_if_0" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.omit_if_0"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>
	/* try doing this stuff after the relocation */
	ldr     r0, =pWTCON
	mov     r1, #0x0
	str     r1, [r0]

	/*
	 * mask all IRQs by setting all bits in the INTMR - default
	 */
	mov	r1, #0xffffffff
	ldr	r0, =INTMR
	str	r1, [r0]

	/* FCLK:HCLK:PCLK = 1:2:4 */
	/* default FCLK is 120 MHz ! */
	ldr	r0, =CLKDIVN
	mov	r1, #3
	str	r1, [r0]
	/* END stuff after relocation */
#endif

	ldr	pc, _start_armboot
<a class="co" name="co.ldr_pc_start_armboot" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.ldr_pc_start_armboot"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a>
_start_armboot:	.word start_armboot
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.omit_if_0"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.omit_if_0"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left"><p>此处忽略已经注释掉的代码</p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.ldr_pc_start_armboot"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.ldr_pc_start_armboot"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>最后的那两行，意思也很简单，那就是将地址为_start_armboot中的内容，即</p>
<p>start_armboot，赋值给PC，即调用start_armboot函数。</p>
<p>至此，汇编语言的start.S的整个工作，就完成了。</p>
<p>而start_armboot函数，在C文件中：</p>
<p><code class="filename">u-boot-1.1.6_20100601\opt\EmbedSky\u-boot-1.1.6\board\EmbedSky\EmbedSky.c</code></p>
<p>中：</p>
<pre class="programlisting">void start_armboot (void)
{
    ......
}
                </pre>
<p>这就是传说中的，调用第二层次，即C语言级别的初始化了，去初始化各个设备了。</p>
<p>其中包括了CPU，内存等，以及串口，正常初始化后，就可以从串口看到uboot的打印信息了。</p>
</td>
</tr>
</tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpu_init_crit"></a>1.5.4.&nbsp;cpu_init_crit</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">/*
 *************************************************************************
 *
 * CPU_init_critical registers
 *
 * setup important registers
 * setup memory timing
 *
 *************************************************************************
 */
#ifndef CONFIG_SKIP_LOWLEVEL_INIT
cpu_init_crit:
	/*
	 * flush v4 I/D caches
	 */
	mov	r0, #0
	mcr<a class="co" name="co.mcr" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.mcr"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>	p15, 0, r0, c7, c7, 0	/* flush v3/v4<a class="co" name="co.flush_v3_v4" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.flush_v3_v4"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a> cache */
	mcr	p15, 0, r0, c8, c7, 0	/* flush v4 TLB */<a class="co" name="co.flush_v4_tlb" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.flush_v4_tlb"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/3.png" alt="3" border="0"></span></a>
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.mcr"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.mcr"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>关于mcr的来龙去脉：</p>
<div class="blockquote"><blockquote class="blockquote">
<p><a class="ulink" href="http://apps.hi.baidu.com/share/detail/32319228" target="_top">http://apps.hi.baidu.com/share/detail/32319228</a></p>
<p>ARM 微处理器可支持多达 16 个协处理器，用于各种协处理操作，在程序执行的过程中，每个协处理器只执行针对自身的协处理指令，忽略 ARM 处理器和其他协处理器的指令。ARM 的协处理器指令主要用于 ARM 处理器初始化 ARM 协处理器的数据处理操作，以及在ARM 处理器的寄存器和协处理器的寄存器之间传送数据，和在 ARM 协处理器的寄存器和存储器之间传送数据。 ARM 协处理器指令包括以下 5 条：</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">CDP 协处理器数操作指令</li>
<li class="listitem">LDC 协处理器数据加载指令</li>
<li class="listitem">STC 协处理器数据存储指令</li>
<li class="listitem">MCR ARM 处理器寄存器到协处理器寄存器的数据传送指令</li>
<li class="listitem">MRC 协处理器寄存器到ARM 处理器寄存器的数据传送指令</li>
</ol></div>
<p>......</p>
<p>CP15系统控制协处理器</p>
<p>CP15 —系统控制协处理器 （the system control coprocessor）他通过协处理器指令MCR和MRC提供具体的寄存器来配置和控制caches、MMU、保护系统、配置时钟模式（在bootloader时钟初始化用到）</p>
<p>CP15的寄存器只能被MRC和MCR（Move to Coprocessor from ARM Register ）指令访问</p>
</blockquote></div>
<p>一些要说明的内容，见下：:</p>
<div class="blockquote"><blockquote class="blockquote">
<p><a class="ulink" href="http://infocenter.arm.com/help/topic/com.arm.doc.ddi0151c/ARM920T_TRM1_S.pdf" target="_top">http://infocenter.arm.com/help/topic/com.arm.doc.ddi0151c/ARM920T_TRM1_S.pdf</a></p>
<p>you can only access CP15 registers with MRC and MCR instructions in a privileged mode. The assembler for these instructions is:</p>
<p>MCR/MRC{cond} P15,opcode_1,Rd,CRn,CRm,opcode_2</p>
<p>The CRn field of MRC and MCR</p>
<p>instructions specifies the coprocessor register to access. The CRm field and opcode_2 fields specify a particular action when addressing registers. The L bit distinguishes between an MRC (L=1) and an MCR (L=0).</p>
<p>Note:</p>
<p>Attempting to read from a nonreadable register, or to write to a nonwritable register causes unpredictable results.</p>
<p>The opcode_1, opcode_2, and CRm fields should be zero, except when the values specified are used to select the desired operations, in all instructions that access CP15. </p>
<p>Using other values results in unpredictable behavior</p>
</blockquote></div>
<p>CP15有很多个寄存器，分别叫做寄存器0(Register 0)，到寄存器15（Register 15），</p>
<p>每个寄存器分别控制不同的功能，而且有的是只读，有的是只写，有的是可读写。</p>
<p>而且这些寄存器的含义，随着版本ARM内核版本变化而不断扩展，详情请参考：<a class="ulink" href="http://www.heyrick.co.uk/assembler/coprocmnd.html" target="_top">Processor setup via co-processor 15 and about co-processors</a></p>
<p>其中，根据我们此处关心的内容，摘录部分内容如下：</p>
<div class="blockquote"><blockquote class="blockquote">
<p>ARM 710</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Register 7 - IDC flush (write only)
                            <p>Any data written to this location will cause the IDC (Instruction/Data cache) to be flushed.</p>
</li></ul></div>
<p>......</p>
<p>StrongARM SA110</p>
<p>......</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">Register 7 - Cache control (write only)
                            <p>Any data written to this location will cause the selected cache to be flushed. </p>
<p>  The OPC_2 and CRm co-processor fields select which cache</p>
<p>  operation should occur:</p>
<p>    Function          OPC_2    CRm     Data</p>
<p><a name="flash_i_d_line"></a>    <span class="emphasis"><em>Flush I + D      %0000    %0111</em></span>   -</p>
<p>    Flush I           %0000    %0101   -</p>
<p>    Flush D           %0000    %0110   -</p>
<p>    Flush D single   %0001    %0110   Virtual address</p>
<p>    Clean D entry    %0001    %1010   Virtual address</p>
<p>    Drain write buf. %0100    %1010  -</p>
</li>
<li class="listitem">Register 8 - TLB operations (write only)
                            <p>Any data written to this location will cause the selected TLB flush operation. </p>
<p>  The OPC_2 and CRm co-processor fields select which cache</p>
<p>  operation should occur:</p>
<p>    Function         OPC_2    CRm    Data</p>
<p>    <span class="emphasis"><em>Flush I + D     %0000    %0111</em></span>  -</p>
<p>    Flush I          %0000    %0101  -</p>
<p>    Flush D          %0000    %0110  -</p>
<p>    Flush D single  %0001    %0110  Virtual address”</p>
</li>
</ul></div>
</blockquote></div>
<p>而MCR的详细的语法为：</p>
<div class="blockquote"><blockquote class="blockquote">
<p>MCR指令</p>
<p>MCR指令将ARM处理器的寄存器中的数据传送到协处理器寄存器中。如果协处理器不能成功地执行该操作，将产生未定义的指令异常中断。</p>
<p>指令语法格式</p>
<p>MCR{&lt;cond&gt;} &lt;p&gt;，&lt; opcode_1&gt;，&lt;Rd&gt;,&lt;CRn&gt;,&lt;CRm&gt;{,&lt;opcode_2&gt;}</p>
<p>MCR{&lt;cond&gt;} p15，0，&lt;Rd&gt;,&lt;CRn&gt;,&lt;CRm&gt;{,&lt;opcode_2&gt;}</p>
<p>其中</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">&lt;cond&gt;
                            <p>指令执行的条件码.当&lt;cond&gt;忽略时指令为无条件执行。</p>
</li>
<li class="listitem">&lt;opcode_1&gt;
                            <p>协处理器将执行的操作的操作码。对于CP15协处理器来说，&lt;opcode_1&gt;永远为0b000，当&lt;opcode_1&gt;不为0b000时，该指令操作结果不可预知。</p>
</li>
<li class="listitem">&lt;Rd&gt;
                            <p>作为源寄存器的ARM寄存器，其值将被传送到协处理器寄存器中</p>
</li>
<li class="listitem">&lt;CRn&gt;
                            <p>作为目标寄存器的协处理器寄存器，其编号可能是C0，C1，…，C15。</p>
</li>
</ul></div>
<p>&lt;CRm&gt;和&lt;opcode_2&gt;两者组合决定对协处理器寄存器进行所需要的操作，如果没有指定，则将为&lt;CRm&gt;为C0，opcode_2为0</p>
</blockquote></div>
<p>对照上面的那行代码：</p>
<pre class="programlisting">mcr	p15, 0, r0, c7, c7, 0	/* flush v3/v4 cache */</pre>
<p>可以看出，其中</p>
<p><span class="emphasis"><em>rd为r0=0</em></span></p>
<p><span class="emphasis"><em>CRn为C7</em></span></p>
<p><span class="emphasis"><em>CRm为C7</em></span></p>
<p>对于这行代码的作用，以此按照语法，来一点点解释如下：</p>
<p>首先，mcr做的事情，其实很简单，就是“<span class="emphasis"><em>ARM处理器的寄存器中的数据传送到协处理器寄存器中</em></span>”，</p>
<p>此处即是，将ARM的寄存器r0中的数据，此时r0=0,所以就是把0这个数据，传送到协处理器CP15中。</p>
<p>而对应就是写入到“<span class="emphasis"><em>&lt;CRn&gt;</em></span>”这个“<span class="emphasis"><em>目标寄存器的协处理器寄存器</em></span>”，此处CRn为C7，即将0写入到寄存器7（Register 7）中去。</p>
<p>而上面关于Register 7的含义中也说了，“Any data written to this location will cause the selected cache to be flushed”，即你往这个寄存器7中写入任何数据，都会导致对应的缓存被清空。而到底那个缓存被清空呢，即我们这行指令</p>
<pre class="programlisting">mcr	p15, 0, r0, c7, c7, 0</pre>
<p>起了什么作用呢</p>
<p>那是由“<span class="emphasis"><em>&lt;CRm&gt;和&lt;opcode_2&gt;两者组合决定</em></span>”的。</p>
<p>而此处CRm为C7，opcode_2为0，而对于C7和0的组合的作用，参见上面的那个表中<a class="xref" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#flash_i_d_line">Register 7中的Flash I+D</a>那一行，</p>
<p>当opcode_2为0，CRm为0111=7，就是我们要找的，其作用是“<span class="emphasis"><em>Flush I + D</em></span>”，即清空指令缓存I Cache和数据缓存D Cache。</p>
<p>根据该表，同理，如果是opcode_2=0，而CRm=0101b=5，那么对应的就是去“<span class="emphasis"><em>Flush I</em></span>”，即只清除指令缓存I Cache了。</p>
<p>而对应的指令也就是</p>
<pre class="programlisting">mcr	p15, 0, r0, c7, c5, 0</pre>
<p>了。</p>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.flush_v3_v4"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.flush_v3_v4"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>此注释说此行代码的作用是，清理v3或v4的缓存</p>
<p>其中v4，我们很好理解，因为我们此处的CPU是ARM920T的核心，是属于ARM V4的，而为何又说，也可以清除v3的cache呢？</p>
<p>那是因为，本身这些寄存器位域的定义，都是向下兼容的，参见上面引用的内容，也写到了：</p>
<div class="blockquote"><blockquote class="blockquote">
<p>ARM 710</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Register 7 - IDC flush (write only)
                            <p>Any data written to this location will cause the IDC (Instruction/Data cache) to be flushed.</p>
</li></ul></div>
</blockquote></div>
<p>即，对于ARM7的话，你写同样的这行代码</p>
<pre class="programlisting">mcr	p15, 0, r0, c7, c7, 0</pre>
<p>也还是向register 7中写入了数据0，这也同样满足了其所说的“Any data written to this location”，也会产生同样的效果“cause the IDC (Instruction/Data cache) to be flushed”。</p>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.flush_v4_tlb"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.flush_v4_tlb"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/3.png" alt="3" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>同理，可以看出此行是去操作寄存器8，而对应的各个参数为：</p>
<p><span class="emphasis"><em>rd为r0=0</em></span></p>
<p><span class="emphasis"><em>CRn为C8</em></span></p>
<p><span class="emphasis"><em>CRm为C7</em></span></p>
<p><span class="emphasis"><em>opcode_2为0</em></span></p>
<p>对照寄存器8的表：</p>
<div class="blockquote"><blockquote class="blockquote"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Register 8 - TLB operations (write only)
                            <p>Any data written to this location will cause the selected TLB flush operation. </p>
<p>  The OPC_2 and CRm co-processor fields select which cache</p>
<p>  operation should occur:</p>
<p>    Function         OPC_2    CRm    Data</p>
<p>    <span class="emphasis"><em>Flush I + D     %0000    %0111</em></span>  -</p>
<p>    Flush I          %0000    %0101  -</p>
<p>    Flush D          %0000    %0110  -</p>
<p>    Flush D single  %0001    %0110  Virtual address”</p>
</li></ul></div></blockquote></div>
<p>其含义为：</p>
<p>向寄存器8中写入数据，会导致对应的TLB被清空。具体是哪个TLB，由opcode_2和CRm组合决定，</p>
<p>此处opcode_2为0，CRm为7=0111b，所以对应的作用是“<span class="emphasis"><em>Flush I + D</em></span>”，即清空指令和数据的TLB。</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[提示]" src="./Uboot中start.S源码的指令级的详尽解析_files/tip.png"></td>
<th align="left">提示</th>
</tr>
<tr><td align="left" valign="top">
<p>上述两行代码，其实都可以ARM的官方网站上面找到：</p>
<div class="blockquote"><blockquote class="blockquote">
<p><a class="ulink" href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0184b/Chdcfejb.html" target="_top">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0184b/Chdcfejb.html</a></p>
<div class="informaltable"><table style="border-collapse: collapse;border-top: 1.5pt solid black; border-bottom: 1.5pt solid black; border-left: 1.5pt solid black; border-right: 1.5pt solid black; ">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Function </th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Rd </th>
<th style="border-bottom: 0.5pt solid green; ">Instruction</th>
</tr></thead>
<tbody><tr>
<td style="border-right: 0.5pt solid green; ">Invalidate ICache and DCache</td>
<td style="border-right: 0.5pt solid green; ">SBZ</td>
<td style="">MCR p15,0,Rd,c7,c7,0</td>
</tr></tbody>
</table></div>
<p><a class="ulink" href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0184b/Chdifbjc.html" target="_top">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0184b/Chdifbjc.html</a></p>
<div class="informaltable"><table style="border-collapse: collapse;border-top: 1.5pt solid black; border-bottom: 1.5pt solid black; border-left: 1.5pt solid black; border-right: 1.5pt solid black; ">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Function </th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Rd </th>
<th style="border-bottom: 0.5pt solid green; ">Instruction</th>
</tr></thead>
<tbody><tr>
<td style="border-right: 0.5pt solid green; ">Invalidate TLB(s)</td>
<td style="border-right: 0.5pt solid green; ">SBZ</td>
<td style="">MCR p15,0,Rd,c8,c7,0</td>
</tr></tbody>
</table></div>
</blockquote></div>
</td></tr>
</tbody></table></div>
</td>
</tr>
</tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="disable_mmu"></a>1.5.5.&nbsp;disable MMU</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">	/*
	 * disable MMU stuff and caches
	 */
	mrc	p15, 0, r0, c1, c0, 0<a class="co" name="co.disable_mmu_cache" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.disable_mmu_cache"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.disable_mmu_cache"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.disable_mmu_cache"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>此处，对应的值为：</p>
<p><span class="emphasis"><em>rd为r0=0</em></span></p>
<p><span class="emphasis"><em>CRn为C1</em></span></p>
<p><span class="emphasis"><em>CRm为C0</em></span></p>
<p><span class="emphasis"><em>opcode_2为0</em></span></p>
<p>即，此行代码是将r0的值，即0，写入到CP15的寄存器1中。</p>
<p>寄存器1的相关的定义为：</p>
<div class="blockquote"><blockquote class="blockquote">
<p><a class="ulink" href="http://www.heyrick.co.uk/assembler/coprocmnd.html" target="_top">http://www.heyrick.co.uk/assembler/coprocmnd.html</a></p>
<p>StrongARM SA110</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Register 1 - Control (read/write)
                            <p>All values set to 0 at power-up.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">Bit  0 - On-chip MMU turned off (0) or on (1)</li>
<li class="listitem">Bit  1 - Address alignment fault disabled (0) or enabled (1)</li>
<li class="listitem">Bit  2 - Data cache turned off (0) or on (1)</li>
<li class="listitem">Bit  3 - Write buffer turned off (0) or on (1)</li>
<li class="listitem">Bit  7 - Little-endian operation if 0, big-endian if 1</li>
<li class="listitem">Bit  8 - System bit - controls the MMU permission system</li>
<li class="listitem">Bit  9 - ROM bit - controls the MMU permission system</li>
<li class="listitem">Bit 12 - Instruction cache turned off (0) or on (1)”</li>
</ul></div>
</li></ul></div>
</blockquote></div>
<p>所以，对应内容就是，向bit[CRm]中写入opcode_2，即向bit[0]写入0，对应的作用为“<span class="emphasis"><em>On-chip MMU turned off</em></span>”，即关闭MMU。</p>
</td>
</tr></tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="clear_bits"></a>1.5.6.&nbsp;clear bits</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">	<a class="co" name="co.clear_bits" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.clear_bits"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>bic	r0, r0, #0x00002300	@ clear bits 13, 9:8 (--V- --RS)<a class="co" name="co.clear_v_rs" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.clear_v_rs"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a>
	bic	r0, r0, #0x00000087	@ clear bits 7, 2:0 (B--- -CAM)<a class="co" name="co.clear_b_cm" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.clear_b_cm"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/3.png" alt="3" border="0"></span></a>
	orr	r0, r0, #0x00000002	@ set bit 2 (A) Align<a class="co" name="co.orr_align" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.orr_align"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/4.png" alt="4" border="0"></span></a>
	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-Cache<a class="co" name="co.orr_icache" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.orr_icache"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/5.png" alt="5" border="0"></span></a>
	mcr	p15, 0, r0, c1, c0, 0<a class="co" name="co.mcr_p15" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.mcr_p15"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/6.png" alt="6" border="0"></span></a>
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.clear_bits"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.clear_bits"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>此处几行代码，注释中写的也很清楚了，就是去清楚对应的位和设置对应的位，具体位域的含义见下：</p>
<div class="blockquote"><blockquote class="blockquote">
<p><a class="ulink" href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0184b/Chdifbjc.html" target="_top">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0184b/Chdifbjc.html</a></p>
<div class="table">
<a name="tbl.ctrl_reg1_bits"></a><p class="title"><b>表&nbsp;1.6.&nbsp;控制寄存器1的位域含义</b></p>
<div class="table-contents"><table summary="控制寄存器1的位域含义" style="border-collapse: collapse;border-top: 1.5pt solid black; border-bottom: 1.5pt solid black; border-left: 1.5pt solid black; border-right: 1.5pt solid black; ">
<colgroup>
<col class="col1">
<col class="col2">
<col class="col3">
<col class="col4">
</colgroup>
<thead><tr>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Register bits</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Name</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Function</th>
<th style="border-bottom: 0.5pt solid green; ">Value</th>
</tr></thead>
<tbody>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">31</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">iA bit</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Asynchronous clock select</td>
<td style="border-bottom: 0.5pt solid green; ">See <a class="ulink" href="http://infocenter.arm.com/help/topic/com.arm.doc.ddi0151c/I66051.html#Cegbgbae" target="_top">Table 2.11</a>
</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">30</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">nF bit</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">notFastBus select</td>
<td style="border-bottom: 0.5pt solid green; ">See <a class="ulink" href="http://infocenter.arm.com/help/topic/com.arm.doc.ddi0151c/I66051.html#Cegbgbae" target="_top">Table 2.11</a>
</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">29:15</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">-</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Reserved</td>
<td style="border-bottom: 0.5pt solid green; "><div class="literallayout"><p>Read&nbsp;=&nbsp;Unpredictable<br>
Write&nbsp;=&nbsp;Should&nbsp;be&nbsp;zero</p></div></td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">14</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">RR bit</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Round robin replacement</td>
<td style="border-bottom: 0.5pt solid green; "><div class="literallayout"><p>0&nbsp;=&nbsp;Random&nbsp;replacement<br>
1&nbsp;=&nbsp;Round-robin&nbsp;replacement</p></div></td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">13</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">V bit</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Base location of exception registers</td>
<td style="border-bottom: 0.5pt solid green; "><div class="literallayout"><p>0&nbsp;=&nbsp;Low&nbsp;addresses&nbsp;=&nbsp;0x00000000<br>
1&nbsp;=&nbsp;High&nbsp;addresses&nbsp;=&nbsp;0xFFFF0000</p></div></td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">12</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">I bit</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">ICache enable</td>
<td style="border-bottom: 0.5pt solid green; "><div class="literallayout"><p>0&nbsp;=&nbsp;ICache&nbsp;disabled<br>
1&nbsp;=&nbsp;ICache&nbsp;enabled</p></div></td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">11:10</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">-</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Reserved</td>
<td style="border-bottom: 0.5pt solid green; "><div class="literallayout"><p>Read&nbsp;=&nbsp;00<br>
Write&nbsp;=&nbsp;00</p></div></td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">9</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">R bit</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">ROM protection</td>
<td style="border-bottom: 0.5pt solid green; ">This bit modifies the MMU protection system. See <a class="ulink" href="http://infocenter.arm.com/help/topic/com.arm.doc.ddi0151c/I273867.html" target="_top">Domain access control</a>
</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">8</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">S bit</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">System protection</td>
<td style="border-bottom: 0.5pt solid green; ">This bit modifies the MMU protection system. See <a class="ulink" href="http://infocenter.arm.com/help/topic/com.arm.doc.ddi0151c/I273867.html" target="_top">Domain access control</a>
</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">7</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">B bit</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Endianness</td>
<td style="border-bottom: 0.5pt solid green; "><div class="literallayout"><p>0&nbsp;=&nbsp;Little-endian&nbsp;operation<br>
1&nbsp;=&nbsp;Big-endian&nbsp;operation</p></div></td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">6:3</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">-</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Reserved</td>
<td style="border-bottom: 0.5pt solid green; "><div class="literallayout"><p>Read&nbsp;=&nbsp;1111<br>
Write&nbsp;=&nbsp;1111</p></div></td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">2</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">C bit</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">DCache enable</td>
<td style="border-bottom: 0.5pt solid green; "><div class="literallayout"><p>0&nbsp;=&nbsp;DCache&nbsp;disabled<br>
1&nbsp;=&nbsp;DCache&nbsp;enabled</p></div></td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">A bit</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Alignment fault enable</td>
<td style="border-bottom: 0.5pt solid green; ">Data address alignment fault checking<div class="literallayout"><p>0&nbsp;=&nbsp;Fault&nbsp;checking&nbsp;disabled<br>
1&nbsp;=&nbsp;Fault&nbsp;checking&nbsp;enabled</p></div>
</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; ">M bit</td>
<td style="border-right: 0.5pt solid green; ">MMU enable</td>
<td style=""><div class="literallayout"><p>0&nbsp;=&nbsp;MMU&nbsp;disabled<br>
1&nbsp;=&nbsp;MMU&nbsp;enabled</p></div></td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><div class="table">
<a name="tbl.clock_mode"></a><p class="title"><b>表&nbsp;1.7.&nbsp;时钟模式</b></p>
<div class="table-contents"><table summary="时钟模式" style="border-collapse: collapse;border-top: 1.5pt solid black; border-bottom: 1.5pt solid black; border-left: 1.5pt solid black; border-right: 1.5pt solid black; ">
<colgroup>
<col class="col1">
<col class="col2">
<col class="col3">
</colgroup>
<thead><tr>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Clocking mode</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">iA</th>
<th style="border-bottom: 0.5pt solid green; ">nF</th>
</tr></thead>
<tbody>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">FastBus mode</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-bottom: 0.5pt solid green; ">0</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Synchronous</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-bottom: 0.5pt solid green; ">1</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Reserved</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-bottom: 0.5pt solid green; ">0</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; ">Asynchronous</td>
<td style="border-right: 0.5pt solid green; ">1</td>
<td style="">1</td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p><a class="ulink" href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0151c/I273867.html" target="_top">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0151c/I273867.html</a></p>
<p>Domain access control</p>
<div class="table">
<a name="tbl.domain_access_ctrl"></a><p class="title"><b>表&nbsp;1.8.&nbsp;关于访问控制位在域访问控制寄存器中的含义</b></p>
<div class="table-contents"><table summary="关于访问控制位在域访问控制寄存器中的含义" style="border-collapse: collapse;border-top: 1.5pt solid black; border-bottom: 1.5pt solid black; border-left: 1.5pt solid black; border-right: 1.5pt solid black; ">
<colgroup>
<col class="col1">
<col class="col2">
<col class="col3">
</colgroup>
<thead><tr>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Value</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Meaning</th>
<th style="border-bottom: 0.5pt solid green; ">Description</th>
</tr></thead>
<tbody>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">00</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">No access</td>
<td style="border-bottom: 0.5pt solid green; ">Any access generates a domain fault</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">01</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Client </td>
<td style="border-bottom: 0.5pt solid green; ">Accesses are checked against the access permission bits in the section or page descriptor</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">10</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Reserved</td>
<td style="border-bottom: 0.5pt solid green; ">Reserved. Currently behaves like the no access mode</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; ">11</td>
<td style="border-right: 0.5pt solid green; ">Manager</td>
<td style="">Accesses are not checked against the access permission bits so a permission fault cannot be generated</td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p><a class="xref" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#tbl.ap_bits" title="表 1.9. 关于访问允许(AP)位的含义">表&nbsp;1.9 “关于访问允许(AP)位的含义”</a>shows how to interpret the Access Permission (AP) bits and how their interpretation is dependent on the S and R bits (control register bits 8 and 9)</p>
<div class="table">
<a name="tbl.ap_bits"></a><p class="title"><b>表&nbsp;1.9.&nbsp;关于访问允许(AP)位的含义</b></p>
<div class="table-contents"><table summary="关于访问允许(AP)位的含义" style="border-collapse: collapse;border-top: 1.5pt solid black; border-bottom: 1.5pt solid black; border-left: 1.5pt solid black; border-right: 1.5pt solid black; ">
<colgroup>
<col class="col1">
<col class="col2">
<col class="col3">
<col class="col4">
<col class="col5">
<col class="col6">
</colgroup>
<thead><tr>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">AP</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">S</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">R</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Supervisor permissions</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">User permissions</th>
<th style="border-bottom: 0.5pt solid green; ">Description</th>
</tr></thead>
<tbody>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">00</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">No access</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">No access </td>
<td style="border-bottom: 0.5pt solid green; ">Any access generates a permission fault</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">00</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Read-only</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">No access</td>
<td style="border-bottom: 0.5pt solid green; ">Only Supervisor read permitted</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">00</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Read-only</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Read-only</td>
<td style="border-bottom: 0.5pt solid green; ">Any write generates a permission fault</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">00</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Reserved</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">-</td>
<td style="border-bottom: 0.5pt solid green; ">-</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">01</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">x</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">x</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Read/write</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">No access </td>
<td style="border-bottom: 0.5pt solid green; ">Access allowed only in Supervisor mode</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">10</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">x</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">x</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Read/write</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Read-only </td>
<td style="border-bottom: 0.5pt solid green; ">Writes in User mode cause permission fault</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">11</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">x</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">x</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Read/write</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Read/write</td>
<td style="border-bottom: 0.5pt solid green; ">All access types permitted in both modes</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; ">xx</td>
<td style="border-right: 0.5pt solid green; ">1</td>
<td style="border-right: 0.5pt solid green; ">1</td>
<td style="border-right: 0.5pt solid green; ">Reserved</td>
<td style="border-right: 0.5pt solid green; ">-</td>
<td style="">&nbsp;</td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break">
</blockquote></div>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.clear_v_rs"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.clear_v_rs"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>此行作用是：</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">清除bit[13]
                        <p>Base location of exception register(异常寄存器基地址)</p>
<p>0 = Low address = 0x0000 0000</p>
</li>
<li class="listitem">清除bit[9]和bit[8]
                        <p>此处不是很懂，待后续深入了解。</p>
<p>目前的理解是：</p>
<p>不论是Supervisor还是user，谁都不能访问，否则就出现权限错误“Any access generates a permission fault”</p>
</li>
</ol></div>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.clear_b_cm"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.clear_b_cm"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/3.png" alt="3" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>此行作用是：</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">清除bit[7]
                        <p>使用little endian</p>
</li>
<li class="listitem">清除bit[2-0]
                        <p>DCache disabled,关闭Dcache；</p>
<p>Alignment Fault checking disabled，关闭地址对齐的错误检查；</p>
<p>MMU disabled，关闭MMU。</p>
</li>
</ol></div>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.orr_align"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.orr_align"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/4.png" alt="4" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>此行作用是：</p>
<div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">设置bit[1]
                        <p>“Enable Data address alignment fault checking”打开数据地址对齐的错误检查，即如果数据地址为非法（奇数？）地址，就报错。</p>
</li></ol></div>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.orr_icache"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.orr_icache"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/5.png" alt="5" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>此行作用是：</p>
<div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">设置bit[12]
                        <p>开启指令缓存I cache。</p>
</li></ol></div>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.mcr_p15"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.mcr_p15"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/6.png" alt="6" border="0"></span></a> </p></td>
<td valign="top" align="left"><p>mcr指令，将刚才设置的r0的值，再写入到寄存器1中。</p></td>
</tr>
</tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="bl_lowlevel_init"></a>1.5.7.&nbsp;bl lowlevel_init</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">	/*
	 * before relocating, we have to setup RAM timing
	 * because memory timing is board-dependend, you will
	 * find a lowlevel_init.S in your board directory.
	 */
	mov	ip, lr
	bl	lowlevel_init
	mov	lr, ip<a class="co" name="co.move_lr_ip" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.move_lr_ip"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>
	mov	pc, lr<a class="co" name="co.move_pc_lr" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.move_pc_lr"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a>
#endif /* CONFIG_SKIP_LOWLEVEL_INIT */<a class="co" name="co.cfg_lowlevel_init" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.cfg_lowlevel_init"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/3.png" alt="3" border="0"></span></a>
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.move_lr_ip"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.move_lr_ip"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>将lr的值给ip，即指令指针r12，此处之所以要保存一下lr是因为此处是在子函数cpu_init_crit中，lr已经保存了待会用于返回主函数的地址，即上次调用时候的pc的值，而此处如果在子函数cpu_init_crit中继续调用其他子函数lowlevel_init,而不保存lr的话，那么调用完lowlevel_init返回来时候，就丢失了cpu_init_crit要返回的位置。</p>
<p>说白了就是，每次你要调用函数之前，你自己要确保是否已经正确保存了lr的值，要保证函数调用完毕后，也能正常返回。当然，如果你此处根本不需要返回，那么就不用去保存lr的值了。</p>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.move_pc_lr"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.move_pc_lr"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a> </p></td>
<td valign="top" align="left"><p>典型的子函数调用，通过将lr的值赋值给pc，实现函数调用完成后而返回的。</p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.cfg_lowlevel_init"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.cfg_lowlevel_init"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/3.png" alt="3" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>这里，其是和前面的代码：</p>
<pre class="programlisting">#ifndef CONFIG_SKIP_LOWLEVEL_INIT
	bl	cpu_init_crit
#endif
                </pre>
<p>是对应的。</p>
</td>
</tr>
</tbody></table></div>
</div>
</div>
</div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="ch01s6_handle_exception"></a>1.6.&nbsp;异常中断处理</h2></div></div></div>
<div class="abstract"><p class="title"><b>摘要</b></p></div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="macros_stmia"></a>1.6.1.&nbsp;macros stmia</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">/*
 *************************************************************************
 *
 * Interrupt handling
 *
 *************************************************************************
 */

@
@ IRQ stack frame.
@
#define S_FRAME_SIZE	72
<a class="co" name="co.s_num_macros" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.s_num_macros"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>
#define S_OLD_R0	68
#define S_PSR		64
#define S_PC		60
#define S_LR		56
#define S_SP		52

#define S_IP		48
#define S_FP		44
#define S_R10		40
#define S_R9		36
#define S_R8		32
#define S_R7		28
#define S_R6		24
#define S_R5		20
#define S_R4		16
#define S_R3		12
#define S_R2		8
#define S_R1		4
#define S_R0		0

#define MODE_SVC 0x13
#define I_BIT	 0x80

/*
 * use bad_save_user_regs for abort/prefetch/undef/swi ...
 * use irq_save_user_regs / irq_restore_user_regs for IRQ/FIQ handling
 */
	.macro<a class="co" name="co.macro" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.macro"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a>	bad_save_user_regs

	sub	sp, sp, #S_FRAME_SIZE<a class="co" name="co.sub_fram_size" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.sub_fram_size"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/3.png" alt="3" border="0"></span></a>
	stmia<a class="co" name="co.stmia" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.stmia"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/4.png" alt="4" border="0"></span></a>	sp, {r0 - r12}			@ Calling r0-r12
	ldr	r2, _armboot_start  <a class="co" name="co.ldr_r2" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.ldr_r2"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/5.png" alt="5" border="0"></span></a>  
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.s_num_macros"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.s_num_macros"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>此处很简单，只是一些宏定义而已。</p>
<p>后面用到的时候再解释。</p>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.macro"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.macro"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>.macro和后面的.endm相对应，其语法是：</p>
<div class="figure">
<a name="fg.macro_syntax"></a><p class="title"><b>图&nbsp;1.12.&nbsp;macro的语法</b></p>
<div class="figure-contents"><div class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tbody><tr><td align="left"><img src="./Uboot中start.S源码的指令级的详尽解析_files/macro_syntax.png" align="left" alt="macro的语法"></td></tr></tbody></table></div></div>
</div>
<br class="figure-break"><p>所以，此处就相当于一个无参数的宏bad_save_user_regs，也就相当于一个函数了。</p>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.sub_fram_size"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.sub_fram_size"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/3.png" alt="3" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>即</p>
<p><span class="emphasis"><em>sp</em></span></p>
<p><span class="emphasis"><em>= sp- S_FRAME_SIZE</em></span></p>
<p><span class="emphasis"><em>= sp - 72</em></span></p>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.stmia"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.stmia"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/4.png" alt="4" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>stmia的语法为：</p>
<div class="figure">
<a name="fg.ldm_stm_syntax"></a><p class="title"><b>图&nbsp;1.13.&nbsp;LDM/STM的语法</b></p>
<div class="figure-contents"><div class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tbody><tr><td align="left"><img src="./Uboot中start.S源码的指令级的详尽解析_files/ldm_stm_syntax.png" align="left" alt="LDM/STM的语法"></td></tr></tbody></table></div></div>
</div>
<br class="figure-break"><p>其中，条件域的具体含义如下：</p>
<div class="figure">
<a name="fg.cond_format"></a><p class="title"><b>图&nbsp;1.14.&nbsp;条件码的含义</b></p>
<div class="figure-contents"><div class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tbody><tr><td align="left"><img src="./Uboot中start.S源码的指令级的详尽解析_files/cond_format.png" align="left" alt="条件码的含义"></td></tr></tbody></table></div></div>
</div>
<br class="figure-break"><p>更具体的含义：</p>
<div class="blockquote"><blockquote class="blockquote">
<p>六、批量数据加载/存储指令ARM微处理器所支持批量数据加载/存储指令可以一次在一片连续的存储器单元和多个寄存器之间传送数据，批量加载指令用于将一片连续的存储器中的数据传送到多个寄存器，批量数据存储指令则完成相反的操作。常用的加载存储指令如下：</p>
<p>LDM（或STM）指令</p>
<p>LDM（或STM）指令的格式为：</p>
<p>LDM（或STM）{条件}{类型} 基址寄存器{！}，寄存器列表{∧}</p>
<p>LDM（或STM）指令用于从由基址寄存器所指示的一片连续存储器到寄存器列表所指示的多个寄存器之间传送数据，该指令的常见用途是将多个寄存器的内容入栈或出栈。</p>
<p>其中，{类型}为以下几种情况：</p>
<p>IA   每次传送后地址加1；</p>
<p>IB   每次传送前地址加1；</p>
<p>DA   每次传送后地址减1；</p>
<p>DB   每次传送前地址减1；</p>
<p>FD   满递减堆栈；</p>
<p>ED   空递减堆栈；</p>
<p>FA   满递增堆栈；</p>
<p>EA   空递增堆栈；</p>
<p>{！}为可选后缀，若选用该后缀，则当数据传送完毕之后，将最后的地址写入基址寄存器，否则基址寄存器的内容不改变。</p>
<p>基址寄存器不允许为R15，寄存器列表可以为R0～R15的任意组合。</p>
<p>{∧}为可选后缀，当指令为LDM且寄存器列表中包含R15，选用该后缀时表示：除了正常的数据传送之外，还将SPSR复制到CPSR。同时，该后缀还表示传入或传出的是用户模式下的寄存器，而不是当前模式下的寄存器。</p>
<p>指令示例：</p>
<p>STMFD  R13!，{R0，R4-R12，LR}        ；将寄存器列表中的寄存器（R0，R4到</p>
<p>                                            R12，LR）存入堆栈。</p>
<p>LDMFD  R13!，{R0，R4-R12，PC}        ；将堆栈内容恢复到寄存器（R0，R4到</p>
<p>                                              R12，LR）。</p>
</blockquote></div>
<p>所以，此行的含义是，</p>
<p>将r0到r12的值，一个个地传送到对应的地址上，基地址是sp的值，传完一个，sp的值加4，一直到传送完为止。</p>
<p>此处，可见，前面那行代码：</p>
<p><span class="emphasis"><em>sp = sp - 72</em></span></p>
<p>就是为此处传送r0到r12，共13个寄存器，地址空间需要13*4=72个字节，</p>
<p>即前面sp减去72，就是为了腾出空间，留此处将r0到r12的值，放到对应的位置的。</p>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.ldr_r2"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.ldr_r2"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/5.png" alt="5" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>此处的含义就是，将_armboot_start中的值，参考前面内容，即为_start,</p>
<p>而_start的值：</p>
<p>从 Nor Flash启动时：<span class="emphasis"><em>_stat=0</em></span></p>
<p>relocate代码之后为：<span class="emphasis"><em>_start=TEXT_BASE=0x33D00000</em></span></p>
<p>此处是已经relocate代码了，所以应该理解为后者，即<span class="emphasis"><em>_start=0x33D00000</em></span></p>
<p>所以:</p>
<p><span class="emphasis"><em>r2=0x33D00000</em></span></p>
</td>
</tr>
</tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cal_reg_value_and_store"></a>1.6.2.&nbsp;cal reg value and store</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">	sub	r2, r2, #(CONFIG_STACKSIZE+CFG_MALLOC_LEN)<a class="co" name="co.sub_r2_malloc_len" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.sub_r2_malloc_len"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>
	sub	r2, r2, #(CFG_GBL_DATA_SIZE+8)  @ set base 2 words into abort stack<a class="co" name="co.gbl_data_size" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.gbl_data_size"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a>
	ldmia	r2, {r2 - r3}			@ get pc, cpsr<a class="co" name="co.get_pc_cpsr" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.get_pc_cpsr"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/3.png" alt="3" border="0"></span></a>
	add	r0, sp, #S_FRAME_SIZE		@ restore sp_SVC<a class="co" name="co.s_frame_size" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.s_frame_size"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/4.png" alt="4" border="0"></span></a>
	add	r5, sp, #S_SP<a class="co" name="co.addr_s_sp" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.addr_s_sp"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/5.png" alt="5" border="0"></span></a>
	mov	r1, lr<a class="co" name="co.mov_r1_lr" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.mov_r1_lr"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/6.png" alt="6" border="0"></span></a>
	stmia	r5, {r0 - r3}			@ save sp_SVC, lr_SVC, pc, cpsr<a class="co" name="co.save_sp_svc" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.save_sp_svc"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/7.png" alt="7" border="0"></span></a>
	mov	r0, sp<a class="co" name="co.mov_r0_sp" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.mov_r0_sp"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/8.png" alt="8" border="0"></span></a>
	.endm<a class="co" name="co.endm" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.endm"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/9.png" alt="9" border="0"></span></a>
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.sub_r2_malloc_len"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.sub_r2_malloc_len"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>此处：</p>
<p><span class="emphasis"><em>r2</em></span></p>
<p>= r2 - ( CONFIG_STACKSIZE+CFG_MALLOC_LEN)</p>
<p>= r2 – (128*1024 + 256*1024)</p>
<p>= 0x33D00000 - 384KB</p>
<p><span class="emphasis"><em>= 0x33CA0000</em></span></p>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.gbl_data_size"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.gbl_data_size"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>此处：</p>
<p><span class="emphasis"><em>r2</em></span></p>
<p>= r2 - (CFG_GBL_DATA_SIZE + 8)</p>
<p>= 0x33CA0000 – (128 + 8)</p>
<p><span class="emphasis"><em>= 0x33C9FF78</em></span></p>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.get_pc_cpsr"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.get_pc_cpsr"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/3.png" alt="3" border="0"></span></a> </p></td>
<td valign="top" align="left"><p>分别将地址为r2和r2+4的内容，即地址为<span class="emphasis"><em>0x33C9FF78</em></span>和<span class="emphasis"><em>0x33C9FF7C</em></span>中的内容，load载入给r2和r3寄存器。</p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.s_frame_size"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.s_frame_size"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/4.png" alt="4" border="0"></span></a> </p></td>
<td valign="top" align="left"><p>将sp的值，加上72，送给r0</p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.addr_s_sp"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.addr_s_sp"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/5.png" alt="5" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>前面的定义是：</p>
<pre class="programlisting">#define S_SP		52</pre>
<p>所以此处就是将sp的值，加上52，送给r5</p>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.mov_r1_lr"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.mov_r1_lr"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/6.png" alt="6" border="0"></span></a> </p></td>
<td valign="top" align="left"><p>将lr给r1</p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.save_sp_svc"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.save_sp_svc"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/7.png" alt="7" border="0"></span></a> </p></td>
<td valign="top" align="left"><p>然后将r0到r3中的内容，存储到地址为r5-r5+12中的位置去。</p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.mov_r0_sp"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.mov_r0_sp"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/8.png" alt="8" border="0"></span></a> </p></td>
<td valign="top" align="left"><p>将sp再赋值给r0</p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.endm"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.endm"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/9.png" alt="9" border="0"></span></a> </p></td>
<td valign="top" align="left"><p>结束宏bad_save_user_regs</p></td>
</tr>
</tbody></table></div>
</div>
</div>
<p>此处虽然每行代码基本看懂了，但是到底此bad_save_user_regs函数是做什么的，还是不太清楚，有待以后慢慢深入理解。</p>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="irq_save_user_regs_irq_restore_user_regs"></a>1.6.3.&nbsp;irq_save_user_regs irq_restore_user_regs</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">	.macro	irq_save_user_regs
	sub	sp, sp, #S_FRAME_SIZE
	stmia	sp, {r0 - r12}			@ Calling r0-r12
	add     r8, sp, #S_PC
	stmdb   r8, {sp, lr}^                   @ Calling SP, LR
	str     lr, [r8, #0]                    @ Save calling PC
	mrs     r6, spsr
	str     r6, [r8, #4]                    @ Save CPSR
	str     r0, [r8, #8]                    @ Save OLD_R0
	mov	r0, sp
	.endm

	.macro	irq_restore_user_regs
	ldmia	sp, {r0 - lr}^			@ Calling r0 - lr
	mov	r0, r0
	ldr	lr, [sp, #S_PC]			@ Get PC
	add	sp, sp, #S_FRAME_SIZE
	subs	pc, lr, #4			@ return &amp; move spsr_svc into cpsr
	.endm
<a class="co" name="co.two_macros" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.two_macros"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>
	.macro get_bad_stack
	ldr	r13, _armboot_start		@ setup our mode stack
	sub	r13, r13, #(CONFIG_STACKSIZE+CFG_MALLOC_LEN)
	sub	r13, r13, #(CFG_GBL_DATA_SIZE+8) @ reserved a couple spots in abort stack
	str	lr, [r13]			@ save caller lr / spsr
	mrs	lr, spsr
	str     lr, [r13, #4] 
	mov	r13, #MODE_SVC			@ prepare SVC-Mode
	@ msr	spsr_c, r13
	msr	spsr, r13
	mov	lr, pc
	movs	pc, lr
	.endm
<a class="co" name="co.get_bad_stack" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.get_bad_stack"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a>
	.macro get_irq_stack			@ setup IRQ stack
	ldr	sp, IRQ_STACK_START
	.endm
<a class="co" name="co.get_irq_stack" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.get_irq_stack"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/3.png" alt="3" border="0"></span></a>
	.macro get_fiq_stack			@ setup FIQ stack
	ldr	sp, FIQ_STACK_START
	.endm
<a class="co" name="co.get_fiq_stack" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.get_fiq_stack"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/4.png" alt="4" border="0"></span></a>
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.two_macros"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.two_macros"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left"><p>上面两段代码，基本上和前面很类似，虽然每一行都容易懂，但是整个两个函数的意思，除了看其宏的名字irq_save_user_regs和irq_restore_user_regs，分别对应着中断中，保存和恢复用户模式寄存器，之外，其他的，个人目前还是没有太多了解。</p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.get_bad_stack"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.get_bad_stack"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a> </p></td>
<td valign="top" align="left"><p>此处的get_bad_stack被后面undefined_instruction，software_interrupt等处调用，目前能理解的意思是，在出错的时候，获得对应的堆栈的值。</p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.get_irq_stack"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.get_irq_stack"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/3.png" alt="3" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>此处的含义很好理解，就是把地址为IRQ_STACK_START中的值赋值给sp。</p>
<p>即获得IRQ的堆栈的起始地址。</p>
<p>而对于IRQ_STACK_START，是前面就提到过的<a class="xref" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#code_cpu_init" title="cpu_init源码">cpu_init源码</a></p>
<p>而此处，就是用到了，前面已经在cpu_init()中重新计算正确的值了。</p>
<p>即算出IRQ堆栈的起始地址，其算法很简单，就是：</p>
<pre class="programlisting">	IRQ_STACK_START = _armboot_start - CFG_MALLOC_LEN - CFG_GBL_DATA_SIZE - 4;</pre>
<p>即，先减去malloc预留的空间，和global data，即在</p>
<p><code class="filename">u-boot-1.1.6_20100601\opt\EmbedSky\u-boot-1.1.6\board\EmbedSky\board.c</code></p>
<p>中定义的全局变量：</p>
<p>DECLARE_GLOBAL_DATA_PTR;</p>
<p>而此宏对应的值在：</p>
<p><code class="filename">u-boot-1.1.6_20100601\opt\EmbedSky\u-boot-1.1.6\include\asm-arm\global_data.h</code></p>
<p>中：</p>
<pre class="programlisting">#define DECLARE_GLOBAL_DATA_PTR     register volatile gd_t *gd asm ("r8")</pre>
<p>即，用一个固定的寄存器r8来存放此结构体的指针。</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[提示]" src="./Uboot中start.S源码的指令级的详尽解析_files/tip.png"></td>
<th align="left">提示</th>
</tr>
<tr><td align="left" valign="top"><p>这也对应着编译uboot的时候，你所看到的编译参数<span class="emphasis"><em>-ffixed-r8</em></span></p></td></tr>
</tbody></table></div>
<p>此gd_t的结构体，不同体系结构，用的不一样。</p>
<p>而此处arm的平台中，gd_t的定义在同一文件中:</p>
<pre class="programlisting">typedef	struct	global_data {
	bd_t		*bd;
	unsigned long	flags;
	unsigned long	baudrate;
	unsigned long	have_console;	/* serial_init() was called */
	unsigned long	reloc_off;	/* Relocation Offset */
	unsigned long	env_addr;	/* Address  of Environment struct */
	unsigned long	env_valid;	/* Checksum of Environment valid? */
	unsigned long	fb_base;	/* base address of frame buffer */
#ifdef CONFIG_VFD
	unsigned char	vfd_type;	/* display type */
#endif
#if 0
	unsigned long	cpu_clk;	/* CPU clock in Hz!		*/
	unsigned long	bus_clk;
	unsigned long	ram_size;	/* RAM size */
	unsigned long	reset_status;	/* reset status register at boot */
#endif
	void		**jt;		/* jump table */
} gd_t;
                </pre>
<p>而此全局变量gd_t *gd会被其他很多文件所引用，详情自己去代码中找。</p>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.get_fiq_stack"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.get_fiq_stack"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/4.png" alt="4" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>此处和上面类似，把地址为FIQ_STACK_START中的内容，给sp。</p>
<p>其中：</p>
<pre class="programlisting">	FIQ_STACK_START = IRQ_STACK_START - CONFIG_STACKSIZE_IRQ;</pre>
<p>即FIQ的堆栈起始地址，是IRQ堆栈起始地址减去IRQ堆栈的大小。</p>
</td>
</tr>
</tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="exception_handlers"></a>1.6.4.&nbsp;exception handlers</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">/*
 * exception handlers
 */
	.align  5
undefined_instruction:<a class="co" name="co.undefined_instruction" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.undefined_instruction"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>
	get_bad_stack
	bad_save_user_regs
	bl 	do_undefined_instruction
	.align	5
    

software_interrupt:
	get_bad_stack
	bad_save_user_regs
	bl 	do_software_interrupt

	.align	5
prefetch_abort:
	get_bad_stack
	bad_save_user_regs
	bl 	do_prefetch_abort

	.align	5
data_abort:
	get_bad_stack
	bad_save_user_regs
	bl 	do_data_abort

	.align	5
not_used:
	get_bad_stack
	bad_save_user_regs
	bl 	do_not_used
<a class="co" name="co.other_several_macros" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.other_several_macros"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a>
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.undefined_instruction"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.undefined_instruction"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>如果发生未定义指令异常，CPU会掉转到start.S开头中对应的位置：</p>
<pre class="programlisting">	ldr	pc, _undefined_instruction</pre>
<p>即把地址为_undefined_instruction中的内容给pc，即跳转到此处执行对应的代码。</p>
<p>其做的事情依次是：</p>
<p><span class="emphasis"><em>获得出错时候的堆栈</em></span></p>
<p><span class="emphasis"><em>保存用户模式寄存器</em></span></p>
<p><span class="emphasis"><em>跳转到对应的函数：do_undefined_instruction</em></span></p>
<p>而do_undefined_instruction函数是在：</p>
<p><code class="filename">u-boot-1.1.6_20100601\opt\EmbedSky\u-boot-1.1.6\cpu\arm920t\interrupts.c</code></p>
<p>中：</p>
<pre class="programlisting">void bad_mode (void)
{
	panic ("Resetting CPU ...\n");
	reset_cpu (0);
}

void do_undefined_instruction (struct pt_regs *pt_regs)
{
	printf ("undefined instruction\n");
	show_regs (pt_regs);
	bad_mode ();
}
                </pre>
<p>可以看到，此处起始啥事没错，只是打印一下出错时候的寄存器的值，然后跳转到bad_mode中取reset CPU，直接重启系统了。</p>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.other_several_macros"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.other_several_macros"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a> </p></td>
<td valign="top" align="left"><p>以上几个宏，和前面的do_undefined_instruction是类似的，就不多说了。</p></td>
</tr>
</tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="launch"></a>1.6.5.&nbsp;Launch</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting">@ HJ
.globl Launch<a class="co" name="co.Launch" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.Launch"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>
    .align	4
Launch:    
    mov r7, r0
    @ diable interrupt
	@ disable watch dog timer
	mov	r1, #0x53000000
	mov	r2, #0x0
	str	r2, [r1]

    ldr r1,=INTMSK
    ldr r2,=0xffffffff  @ all interrupt disable
    str r2,[r1]

    ldr r1,=INTSUBMSK
    ldr r2,=0x7ff       @ all sub interrupt disable
    str r2,[r1]

    ldr     r1, = INTMOD
    mov r2, #0x0        @ set all interrupt as IRQ (not FIQ)
    str     r2, [r1]

    @ 
	mov	ip, #0
	mcr	p15, 0, ip, c13, c0, 0      @	/* zero PID */
	mcr	p15, 0, ip, c7, c7, 0       @	/* invalidate I,D caches */
	mcr	p15, 0, ip, c7, c10, 4      @	/* drain write buffer */
	mcr	p15, 0, ip, c8, c7, 0       @	/* invalidate I,D TLBs */
	mrc	p15, 0, ip, c1, c0, 0       @	/* get control register */
	bic	ip, ip, #0x0001             @	/* disable MMU */
	mcr	p15, 0, ip, c1, c0, 0       @	/* write control register */

    @ MMU_EnableICache
    @mrc p15,0,r1,c1,c0,0
    @orr r1,r1,#(1&lt;&lt;12)
    @mcr p15,0,r1,c1,c0,0

#ifdef CONFIG_SURPORT_WINCE
    bl Wince_Port_Init
#endif

    @ clear SDRAM: the end of free mem(has wince on it now) to the end of SDRAM
    ldr     r3, FREE_RAM_END
    ldr     r4, =PHYS_SDRAM_1+PHYS_SDRAM_1_SIZE    @ must clear all the memory unused to zero
    mov     r5, #0

    ldr     r1, _armboot_start
    ldr     r2, =On_Steppingstone
    sub     r2, r2, r1
    mov     pc, r2
On_Steppingstone:
2:  stmia   r3!, {r5}
    cmp     r3, r4
    bne     2b

    @ set sp = 0 on sys mode
    mov sp, #0

    @ add by HJ, switch to SVC mode
	msr	cpsr_c,	#0xdf	@ set the I-bit = 1, diable the IRQ interrupt
	msr	cpsr_c,	#0xd3	@ set the I-bit = 1, diable the IRQ interrupt
    ldr sp, =0x31ff5800	
    
    nop
	nop
    nop
	nop

	mov     pc, r7  @ Jump to PhysicalAddress
	nop
    mov pc, lr
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.Launch"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.Launch"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>此处相当于一个叫做Launch的函数，做了也是类似的系统初始化的动作。</p>
<p>但是没找到此函数在哪里被调用的。具体不太清楚。</p>
</td>
</tr></tbody></table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="int_return"></a>1.6.6.&nbsp;int_return</h3></div></div></div>
<div class="programlistingco">
<pre class="programlisting"><a class="co" name="co.int_return" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.int_return"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>
#ifdef CONFIG_USE_IRQ
	.align	5
irq:
/* add by www.embedsky.net to use IRQ for USB and DMA */
	sub	lr, lr, #4			        @ the return address
	ldr	sp, IRQ_STACK_START	        @ the stack for irq
	stmdb	sp!, 	{ r0-r12,lr }	@ save registers
	
	ldr	lr,	=int_return		        @ set the return addr
	ldr	pc, =IRQ_Handle<a class="co" name="co.irq_handle" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.irq_handle"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a>		        @ call the isr
int_return:
	ldmia	sp!, 	{ r0-r12,pc }^	@ return from interrupt
	.align	5
fiq:<a class="co" name="co.fiq" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.fiq"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/3.png" alt="3" border="0"></span></a>
	get_fiq_stack
	/* someone ought to write a more effiction fiq_save_user_regs */
	irq_save_user_regs
	bl 	do_fiq<a class="co" name="co.do_fiq" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.do_fiq"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/4.png" alt="4" border="0"></span></a>
	irq_restore_user_regs
#else
<a class="co" name="co.else_part" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.else_part"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/5.png" alt="5" border="0"></span></a>
	.align	5
irq:
	get_bad_stack
	bad_save_user_regs
	bl 	do_irq

	.align	5
fiq:
	get_bad_stack
	bad_save_user_regs
	bl 	do_fiq

#endif
        </pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.int_return"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.int_return"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>此处，做的事情，很容易看懂，就是中断发生后，掉转到这里，然后保存对应寄存器，然后跳转到对应irq函数IRQ_Handle中去。</p>
<p>但是前面为何sp为何去减去4，原因不太懂。</p>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.irq_handle"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.irq_handle"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>关于IRQ_Handle，是在：</p>
<p><code class="filename">u-boot-1.1.6_20100601\opt\EmbedSky\u-boot-1.1.6\cpu\arm920t\s3c24x0\interrupts.c</code></p>
<p>中：</p>
<pre class="programlisting">void IRQ_Handle(void)
{
	unsigned long oft = intregs-&gt;INTOFFSET;
	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();

//	printk("IRQ_Handle: %d\n", oft);

	//清中断
	if( oft == 4 ) gpio-&gt;EINTPEND = 1&lt;&lt;7;	
	intregs-&gt;SRCPND = 1&lt;&lt;oft;
	intregs-&gt;INTPND	= intregs-&gt;INTPND;

	/* run the isr */
	isr_handle_array[oft]();
}
                </pre>
<p>此处细节就不多解释了，大体含义是，找到对应的中断源，然后调用对应的之前已经注册的中断服务函数ISR。</p>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.fiq"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.fiq"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/3.png" alt="3" border="0"></span></a> </p></td>
<td valign="top" align="left"><p>此处也很简单，就是发生了快速中断FIQ的时候，保存IRQ的用户模式寄存器，然后调用函数do_fiq,调用完毕后，再恢复IRQ的用户模式寄存器。</p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.do_fiq"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.do_fiq"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/4.png" alt="4" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>do_fiq()是在：</p>
<p><code class="filename">u-boot-1.1.6_20100601\opt\EmbedSky\u-boot-1.1.6\cpu\arm920t\interrupts.c</code></p>
<p>中：</p>
<pre class="programlisting">void do_fiq (struct pt_regs *pt_regs)
{
	printf ("fast interrupt request\n");
	show_regs (pt_regs);
	bad_mode ();
}
                </pre>
<p>和前面提到过的do_undefined_instruction的一样，就是打印寄存器信息，然后跳转到bad_mode()去重启CPU而已。</p>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.else_part"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.else_part"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/5.png" alt="5" border="0"></span></a> </p></td>
<td valign="top" align="left"><p>此处就是，如果没有定义CONFIG_USE_IRQ，那么就用这段代码，可以看到，都只是直接调用do_irq和do_fiq，也没做什么实际工作。</p></td>
</tr>
</tbody></table></div>
</div>
</div>
</div>
</div>
<div class="chapter">
<div class="titlepage"><div><div><h1 class="title">
<a name="ch02_starts_summary"></a>第&nbsp;2&nbsp;章&nbsp;start.S的总结</h1></div></div></div>
<div class="toc">
<p><b>目录</b></p>
<dl class="toc">
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#start_s_summary">2.1. start.S各个部分的总结</a></span></dt>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#uboot_mem_layout">2.2. Uboot中的内存的Layout</a></span></dt>
</dl>
</div>
<div class="abstract"><p class="title"><b>摘要</b></p></div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="start_s_summary"></a>2.1.&nbsp;start.S各个部分的总结</h2></div></div></div>
<p>其实关于start.S这个汇编文件，主要做的事情就是系统的各个方面的初始化。</p>
<p>关于每个部分，上面具体的代码实现，也都一行行的解释过了，此处不再赘述。</p>
<p>此处，只是简单总结一下，其实现的方式，或者其他需要注意的地方。</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<span class="emphasis"><em>设置CPU模式</em></span><p>总的来说，就是将CPU设置为SVC模式。</p>
<p>至于为何设置CPU是SVC模式，请参见后面章节的详细解释。</p>
</li>
<li class="listitem">
<span class="emphasis"><em>关闭看门狗</em></span><p>就是去设置对应的寄存器，将看门狗关闭。</p>
<p>至于为何关闭看门狗，请参见后面章节的详细解释。</p>
</li>
<li class="listitem">
<span class="emphasis"><em>关闭中断</em></span><p>关闭中断，也是去设置对应的寄存器，即可。</p>
</li>
<li class="listitem">
<span class="emphasis"><em>设置堆栈sp指针</em></span><p>所谓的设置堆栈sp指针，这样的句子，之前听到N次了，但是说实话，一直不太理解，到底更深一层的含义是什么。</p>
<p>后来，看了更多的代码，才算有一点点了解。所谓的设置堆栈sp指针，就是设置堆栈，而所谓的设置堆栈，要做的事情，看起来很简单，就只是一个很简单的动作：让sp等于某个地址值，即可。</p>
<p>但是背后的逻辑是：</p>
<p>首先你自己要搞懂当前系统是如何使用堆栈的，堆栈是向上生长的还是向下生长的。</p>
<p>然后知道系统如何使用堆栈之后，给sp赋值之前，你要保证对应的地址空间，是专门分配好了，专门给堆栈用的，保证堆栈的大小相对合适，而不要太小以至于后期函数调用太多，导致堆栈溢出，或者堆栈太大，浪费存储空间，等等。</p>
<p>所有这些背后的逻辑，都是要经过一定的编程经验，才更加容易理解其中的含义的。</p>
<p>此处，也只是简单说说，更多相关的内容，还是要靠每个人自己多实践，慢慢的更加深入的理解。</p>
</li>
<li class="listitem">
<span class="emphasis"><em>清除bss段</em></span><p>此处很简单，就是将对应bss段，都设置为,0，即清零。</p>
<p>其对应的地址空间，就是那些未初始化的全局变量之类的地址。</p>
</li>
<li class="listitem">
<span class="emphasis"><em>异常中断处理</em></span><p>异常中断处理，就是实现对应的常见的那些处理中断的部分内容。</p>
<p>说白了就是实现一个个中断函数。uboot在初始化的时候，主要目的只是为了初始化系统，及引导系统，所以，此处的中断处理部分的代码，往往相对比较简单，不是很复杂。</p>
</li>
</ol></div>
</div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="uboot_mem_layout"></a>2.2.&nbsp;Uboot中的内存的Layout</h2></div></div></div>
<p>总结了start.S做的事情之后，另外想在此总结一下，uboot中，初始化部分的代码执行后，对应的内存空间，都是如何规划，什么地方放置了什么内容。此部分内容，虽然和start.S没有直接的关系，但是start.S中，堆栈sp的计算等，也和这部分内容有关。</p>
<p>下面这部分的uboot的内存的layout，主要是根据：</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">start.S中关于设置堆栈指针的部分的代码
            <pre class="programlisting">	/* Set up the stack						    */
stack_setup:
	ldr	r0, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */
	sub	r0, r0, #CFG_MALLOC_LEN	/* malloc area                      */
	sub	r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo                        */

#ifdef CONFIG_USE_IRQ
	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)
#endif
	sub	sp, r0, #12		/* leave 3 words for abort-stack    */

	bl clock_init
            </pre>
</li>
<li class="listitem">
<code class="filename">u-boot-1.1.6_20100601\opt\EmbedSky\u-boot-1.1.6\cpu\arm920t\cpu.c</code>中的代码
            <pre class="programlisting">int cpu_init (void)
{
	/*
	 * setup up stacks if necessary
	 */
#ifdef CONFIG_USE_IRQ
	IRQ_STACK_START = _armboot_start - CFG_MALLOC_LEN - CFG_GBL_DATA_SIZE - 4;
	FIQ_STACK_START = IRQ_STACK_START - CONFIG_STACKSIZE_IRQ;
    FREE_RAM_END = FIQ_STACK_START - CONFIG_STACKSIZE_FIQ - CONFIG_STACKSIZE;
    FREE_RAM_SIZE = FREE_RAM_END - PHYS_SDRAM_1;
#else    
    FREE_RAM_END = _armboot_start - CFG_MALLOC_LEN - CFG_GBL_DATA_SIZE - 4 - CONFIG_STACKSIZE;
    FREE_RAM_SIZE = FREE_RAM_END - PHYS_SDRAM_1;
#endif
	return 0;
}
            </pre>
</li>
<li class="listitem">
<code class="filename">u-boot-1.1.6_20100601\opt\EmbedSky\u-boot-1.1.6\board\EmbedSky\config.mk</code>中的定义
            <pre class="programlisting">TEXT_BASE = 0x33D00000</pre>
</li>
</ol></div>
<p>分析而得出的。</p>
<p>uboot的内存的layout，用图表表示就是：</p>
<div class="figure">
<a name="fg.uboot_mem_layout"></a><p class="title"><b>图&nbsp;2.1.&nbsp;Uboot中的内存的Layout</b></p>
<div class="figure-contents"><div class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tbody><tr><td align="left"><img src="./Uboot中start.S源码的指令级的详尽解析_files/uboot_mem_layout.png" align="left" alt="Uboot中的内存的Layout"></td></tr></tbody></table></div></div>
</div>
<br class="figure-break">
</div>
</div>
<div class="chapter">
<div class="titlepage"><div><div><h1 class="title">
<a name="ch03_related_knowledge"></a>第&nbsp;3&nbsp;章&nbsp;相关知识点详解</h1></div></div></div>
<div class="toc">
<p><b>目录</b></p>
<dl class="toc">
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#how_to_see_real_assembly">3.1. 如何查看C或汇编的源代码所对应的真正的汇编代码</a></span></dt>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#why_svc_not_other">3.2. uboot初始化中，为何要设置CPU为SVC模式而不是设置为其他模式</a></span></dt>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#why_close_wdt">3.3. 什么是watchdog + 为何在要系统初始化的时候关闭watchdog</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#idp3122432">3.3.1. 什么是watchdog</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#idp3125440">3.3.2. 为何在要系统初始化的时候关闭watchdog</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#why_arm7_pc_8">3.4. 为何ARM7中PC=PC+8</a></span></dt>
<dd><dl><dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#idp3138744">3.4.1. 为何ARM9和ARM7一样，也是PC=PC+8</a></span></dt></dl></dd>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#arm_reg_name_apcs">3.5. AMR寄存器的别名 + APCS</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#arm_reg_alias">3.5.1. ARM中的寄存器的别名</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#what_is_apcs">3.5.2. 什么是APCS</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#why_c_need_stack">3.6. 为何C语言（的函数调用）需要堆栈，而汇编语言却不需要堆栈</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#save_context">3.6.1. 保存现场/上下文</a></span></dt>
<dd><dl><dt><span class="sect3"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#idp1816936">3.6.1.1. 什么叫做上下文context</a></span></dt></dl></dd>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#pass_parameter">3.6.2. 传递参数</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#exampe_show_c_stack">3.6.3. 举例分析C语言函数调用是如何使用堆栈的</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#why_adr_not_move">3.7. 关于为何不直接用mov指令，而非要用adr伪指令</a></span></dt>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#mov_value_range">3.8. mov指令的操作数的取值范围到底是多少</a></span></dt>
<dt><span class="sect1"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#summary_assembly">3.9. 汇编学习总结记录</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#assembly_label_c_label">3.9.1. 汇编中的标号=C中的标号</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#assembly_b_c_goto">3.9.2. 汇编中的跳转指令=C中的goto</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#assembly_globl_c_extern">3.9.3. 汇编中的.globl=C语言中的extern</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#bl_mov_pc_lr_mean_func_call">3.9.4. 汇编中用bl指令和mov pc，lr来实现子函数调用和返回</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#assembly_label_c_pointer">3.9.5. 汇编中的对应位置有存储值的标号 = C语言中的指针变量</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#assembly_ldr_c_func_call">3.9.6. 汇编中的ldr+标号，来实现C中的函数调用</a></span></dt>
<dt><span class="sect2"><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#assembly_set_value_for_reg">3.9.7. 汇编中设置某个寄存器的值或给某个地址赋值</a></span></dt>
</dl></dd>
</dl>
</div>
<div class="abstract"><p class="title"><b>摘要</b></p></div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="how_to_see_real_assembly"></a>3.1.&nbsp;如何查看C或汇编的源代码所对应的真正的汇编代码</h2></div></div></div>
<p>首先解释一下，由于汇编代码中会存在一些伪指令等内容，所以，写出来的汇编代码，并不一定是真正可以执行的代码，这些类似于伪指令的汇编代码，经过汇编器，转换或翻译成真正的可以执行的汇编指令。所以，上面才会有将“汇编源代码”转换为“真正的汇编代码”这一说。</p>
<p>然后，此处对于有些人不是很熟悉的，如何查看源代码真正对应的汇编代码。</p>
<p>此处，对于汇编代码，有两种：</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">一种是只是进过编译阶段，生成了对应的汇编代码</li>
<li class="listitem">另外一种是，编译后的汇编代码，经过链接器链接后，对应的汇编代码。</li>
</ol></div>
<p>总的来说，两者区别很小，后者主要是更新了外部函数的地址等等，对于汇编代码本身，至少对于我们一般所去查看源代码所对应的汇编来说，两者可以视为没区别。</p>
<p>在查看源代码所对应的真正的汇编代码之前，先要做一些相关准备工作：</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<span class="emphasis"><em>编译uboot</em></span><p>在Linux下，一般编译uboot的方法是：</p>
<div class="orderedlist"><ol class="orderedlist" type="a">
<li class="listitem">
<pre class="screen">make distclean</pre>
<p>去清除之前配置，编译等生成的一些文件。</p>
</li>
<li class="listitem">
<pre class="screen">make EmbedSky_config</pre>
<p>去配置我们的uboot</p>
</li>
<li class="listitem">
<pre class="screen">make</pre>
<p>去执行编译</p>
</li>
</ol></div>
</li>
<li class="listitem">
<span class="emphasis"><em>查看源码所对应的汇编代码</em></span><p>对于我们此处的uboot的start.S来说：</p>
<div class="orderedlist"><ol class="orderedlist" type="a">
<li class="listitem">对于编译所生成的汇编的查看方式是
                    <p>用交叉编译器的dump工具去将汇编代码都导出来：</p>
<pre class="screen">arm-linux-objdump –d cpu/arm920t/start.o &gt; uboot_start.o_dump_result.txt</pre>
<p>这样就把start.o中的汇编代码导出到uboot_start.o_dump_result.txt中了。</p>
<p>然后查看uboot_start.o_dump_result.txt，即可找到对应的汇编代码。</p>
<p>举例来说，对于start.S中的汇编代码：</p>
<pre class="programlisting">	/* Set up the stack						    */
stack_setup:
	ldr	r0, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */
	sub	r0, r0, #CFG_MALLOC_LEN	/* malloc area                      */
	sub	r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo                        */

#ifdef CONFIG_USE_IRQ
	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)
#endif
	sub	sp, r0, #12		/* leave 3 words for abort-stack    */

	bl clock_init
                    </pre>
<p>去uboot_start.o_dump_result.txt中，搜索stack_setup，即可找到对应部分的汇编代码：</p>
<pre class="screen">00000090 &lt;stack_setup&gt;:
  90:	e51f0058 	ldr	r0, [pc, #-88]	; 40 &lt;_TEXT_BASE&gt;
  94:	e2400701 	sub	r0, r0, #262144	; 0x40000
  98:	e2400080 	sub	r0, r0, #128	; 0x80
  9c:	e240d00c 	sub	sp, r0, #12	; 0xc
  a0:	ebfffffe 	bl	0 &lt;clock_init&gt;
                    </pre>
</li>
<li class="listitem">对于链接所生成的汇编的查看方式是
                    <p>和上面方法一样，即：</p>
<pre class="screen">arm-linux-objdump –d u-boot &gt; whole_uboot_dump_result.txt</pre>
<p>然后打开该txt，找到stack_setup部分的代码：</p>
<pre class="programlisting">33d00090 &lt;stack_setup&gt;:
33d00090:	e51f0058 	ldr	r0, [pc, #-88]	; 33d00040 &lt;_TEXT_BASE&gt;
33d00094:	e2400701 	sub	r0, r0, #262144	; 0x40000
33d00098:	e2400080 	sub	r0, r0, #128	; 0x80
33d0009c:	e240d00c 	sub	sp, r0, #12	; 0xc
33d000a0:	eb000242 	bl	33d009b0 &lt;clock_init&gt;
                    </pre>
<p>两者不一样地方在于，我们uboot设置了text_base，即代码段的基地址，上面编译后的汇编代码，经过链接后，更新了对应的基地址，所以看起来，所以代码对应的地址，都变了，但是具体地址中的汇编代码，除了个别调用函数的地址和跳转到某个标号的地址之外，其他都还是一样的。</p>
</li>
</ol></div>
</li>
</ol></div>
<p>对于C语言的源码，也是同样的方法，用对应的dump工具，去从该C语言的.o文件中，dump出来汇编代码。</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="./Uboot中start.S源码的指令级的详尽解析_files/note.png"></td>
<th align="left">注意</th>
</tr>
<tr><td align="left" valign="top">
<p>【总结】</p>
<p><span class="emphasis"><em>不论是C语言还是汇编语言的源文件，想要查看其对应的生成的汇编代码的话，方法很简单，就是用dump工具，从对应的.o目标文件中，导出对应的汇编代码，即可。</em></span></p>
</td></tr>
</tbody></table></div>
</div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="why_svc_not_other"></a>3.2.&nbsp;uboot初始化中，为何要设置CPU为SVC模式而不是设置为其他模式</h2></div></div></div>
<p>在看Uboot的start.S文件时候，发现其最开始初始化系统，做的第一件事情，就是将CPU设置为SVC模式，但是S3C2440的CPU的core是ARM920T，其有7种模式，为何非要设置为SVC模式，而不是设置为其他模式呢？对此，经过一些求证，得出如下原因：</p>
<p>首先，先要了解ARM的CPU的7种模式是哪些：</p>
<p><a class="ulink" href="http://www.docin.com/p-73665362.html" target="_top">http://www.docin.com/p-73665362.html</a></p>
<div class="table">
<a name="tbl.arm_cpu_mode"></a><p class="title"><b>表&nbsp;3.1.&nbsp;ARM中CPU的模式</b></p>
<div class="table-contents"><table summary="ARM中CPU的模式" style="border-collapse: collapse;border-top: 1.5pt solid black; border-bottom: 1.5pt solid black; border-left: 1.5pt solid black; border-right: 1.5pt solid black; ">
<colgroup>
<col class="col1">
<col class="col2">
<col class="col3">
</colgroup>
<thead><tr>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">处理器模式</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">说明</th>
<th style="border-bottom: 0.5pt solid green; ">备注</th>
</tr></thead>
<tbody>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">用户(usr)</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">正常程序工作模式</td>
<td style="border-bottom: 0.5pt solid green; ">此模式下程序不能够访问一些受操作系统保护的系统资源，应用程序也不能直接进行处理器模式的切换。</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">系统(sys)</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">用于支持操作系统的特权任务等</td>
<td style="border-bottom: 0.5pt solid green; ">与用户模式类似，但具有可以直接切换到其它模式等特权</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">快中断(fiq)</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">支持高速数据传输及通道处理</td>
<td style="border-bottom: 0.5pt solid green; ">FIQ异常响应时进入此模式</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">中断(irq)</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">用于通用中断处理</td>
<td style="border-bottom: 0.5pt solid green; ">IRQ异常响应时进入此模式</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">管理(svc)</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">操作系统保护代码</td>
<td style="border-bottom: 0.5pt solid green; ">系统复位和软件中断响应时进入此模式</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">中止(abt)</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">用于支持虚拟内存和/或存储器保护</td>
<td style="border-bottom: 0.5pt solid green; ">在ARM7TDMI没有大用处</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; ">未定义(und)</td>
<td style="border-right: 0.5pt solid green; ">支持硬件协处理器的软件仿真</td>
<td style="">未定义指令异常响应时进入此模式</td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>另外，7种模式中，除用户usr模式外，其它模式均为特权模式。</p>
<p>对于为何此处是svc模式，而不是其他某种格式，其原因，可以从两方面来看：</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<p>我们先简单的来分析一下那7种模式：</p>
<div class="orderedlist"><ol class="orderedlist" type="a">
<li class="listitem">中止abt和未定义und模式
                    <p>首先可以排除的是，中止abt和未定义und模式，那都是不太正常的模式，此处程序是正常运行的，所以不应该设置CPU为其中任何一种模式，所以可以排除。</p>
</li>
<li class="listitem">快中断fiq和中断irq模式
                    <p>其次，对于快中断fiq和中断irq来说，此处uboot初始化的时候，也还没啥中断要处理和能够处理，而且即使是注册了终端服务程序后，能够处理中断，那么这两种模式，也是自动切换过去的，所以，此处也不应该设置为其中任何一种模式。</p>
</li>
<li class="listitem">用户usr模式
                    <p>虽然从理论上来说，可以设置CPU为用户usr模式，但是由于此模式无法直接访问很多的硬件资源，而uboot初始化，就必须要去访问这类资源，所以此处可以排除，不能设置为用户usr模式。</p>
</li>
<li class="listitem">系统sys模式 vs 管理svc模式
                    <p>首先，sys模式和usr模式相比，所用的寄存器组，都是一样的，但是增加了一些访问一些在usr模式下不能访问的资源。</p>
<p>而svc模式本身就属于特权模式，本身就可以访问那些受控资源，而且，比sys模式还多了些自己模式下的影子寄存器，所以，相对sys模式来说，可以访问资源的能力相同，但是拥有更多的硬件资源。</p>
<p>所以，从理论上来说，虽然可以设置为sys和svc模式的任一种，但是从uboot方面考虑，其要做的事情是初始化系统相关硬件资源，需要获取尽量多的权限，以方便操作硬件，初始化硬件。</p>
</li>
</ol></div>
<p>从uboot的目的是初始化硬件的角度来说，设置为svc模式，更有利于其工作。</p>
<p>因此，此处将CPU设置为SVC模式。</p>
</li>
<li class="listitem">
<p>uboot作为一个bootloader来说，最终目的是为了启动Linux的kernel，在做好准备工作（即初始化硬件，准备好kernel和rootfs等）跳转到kernel之前，本身就要满足一些条件，其中一个条件，就是要求CPU处于SVC模式的。</p>
<p>所以，uboot在最初的初始化阶段，就将CPU设置为SVC模式，也是最合适的。</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[提示]" src="./Uboot中start.S源码的指令级的详尽解析_files/tip.png"></td>
<th align="left">提示</th>
</tr>
<tr><td align="left" valign="top">
<p>关于满足哪些条件，详情请参考</p>
<p><a class="ulink" href="http://www.arm.linux.org.uk/developer/booting.php" target="_top">ARM Linux Kernel Boot Requirements</a></p>
<p>或者Linux内核文档:</p>
<p><code class="filename">kernel_source_root\documentation\arm\booting</code></p>
<p>中也是同样的解释：</p>
<div class="blockquote"><blockquote class="blockquote"><p>The CPU must be in SVC mode</p></blockquote></div>
</td></tr>
</tbody></table></div>
<p>所以，uboot在最初的初始化阶段，就将CPU设置为SVC模式，也是最合适的。</p>
</li>
</ol></div>
<p>综上所述，uboot在初始化阶段，就应该将CPU设置为SVC模式。</p>
</div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="why_close_wdt"></a>3.3.&nbsp;什么是watchdog + 为何在要系统初始化的时候关闭watchdog</h2></div></div></div>
<p>关于Uboot初始化阶段，在start.S中，为何要去关闭watchdog，下面解释具体的原因：</p>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="idp3122432"></a>3.3.1.&nbsp;什么是watchdog</h3></div></div></div>
<p>参考<a class="ulink" href="http://wenku.baidu.com/view/e5cd52ff04a1b0717fd5dd27.html" target="_top">嵌入式系统之WATCHDOG(看门狗)概述</a></p>
<p>简要摘录如下：</p>
<p>watchdog一般是一个硬件模块，其作用是，在嵌入式操作系统中，很多应用情况是系统长期运行且无人看守，所以难免或者怕万一出现系统死机，那就杯具了，这时，watchdog就会自动帮你重启系统。</p>
<p>那么其是如何实现此功能的呢？那么就要简单解释一下其实现原理了。</p>
<p>watchdog硬件的逻辑就是，其硬件上有个记录超时功能，然后要求用户需要每隔一段时间（此时间可以根据自己需求而配置）去对其进行一定操作，比如往里面写一些固定的值，俗称“喂狗”，那么我发现超时了，即过了这么长时间你还不给偶喂食，那么偶就认为你系统是死机了，出问题了，偶就帮你重启系统。</p>
<p>说白了就是弄个看家狗dog，你要定期给其喂食，如果超时不喂食，那么狗就认为你，他的主人，你的系统，死机了，就帮你reset重启系统。</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="idp3125440"></a>3.3.2.&nbsp;为何在要系统初始化的时候关闭watchdog</h3></div></div></div>
<p>了解了watchdog的原理后，此问题就很容易理解了。</p>
<p>如果不禁用watchdog，那么就要单独写程序去定期“喂狗”，那多麻烦，多无聊啊。</p>
<p>毕竟咱此处只是去用uboot初始化必要的硬件资源和系统资源而已，完全用不到这个watchdog的机制。需要用到，那也是你linux内核跑起来了，是你系统关心的事情，和我uboot没啥关系的，所以肯定此处要去关闭watchdog（的reset功能）了。</p>
</div>
</div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="why_arm7_pc_8"></a>3.4.&nbsp;为何ARM7中PC=PC+8</h2></div></div></div>
<p>此处解释为何ARM7中，CPU地址，即PC，为何有PC=PC+8这一说法：</p>
<p>众所周知，AMR7，是三级流水线，其细节见图：</p>
<div class="figure">
<a name="fg.arm_3_tie_pipeline"></a><p class="title"><b>图&nbsp;3.1.&nbsp;AMR7三级流水线</b></p>
<div class="figure-contents"><div class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tbody><tr><td align="left"><img src="./Uboot中start.S源码的指令级的详尽解析_files/arm_3_tie_pipeline.jpg" align="left" alt="AMR7三级流水线"></td></tr></tbody></table></div></div>
</div>
<br class="figure-break"><p>首先，对于ARM7对应的流水线的执行情况，如下面这个图所示：</p>
<div class="figure">
<a name="fg.arm_3_tie_pipeline_state"></a><p class="title"><b>图&nbsp;3.2.&nbsp;ARM7三级流水线状态</b></p>
<div class="figure-contents"><div class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tbody><tr><td align="left"><img src="./Uboot中start.S源码的指令级的详尽解析_files/arm_3_tie_pipeline_state.jpg" align="left" alt="ARM7三级流水线状态"></td></tr></tbody></table></div></div>
</div>
<br class="figure-break"><p>然后对于三级流水线举例如下：</p>
<div class="figure">
<a name="fg.arm_3_tie_pipeline_example"></a><p class="title"><b>图&nbsp;3.3.&nbsp;ARM7三级流水线示例</b></p>
<div class="figure-contents"><div class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tbody><tr><td align="left"><img src="./Uboot中start.S源码的指令级的详尽解析_files/arm_3_tie_pipeline_example.jpg" align="left" alt="ARM7三级流水线示例"></td></tr></tbody></table></div></div>
</div>
<br class="figure-break"><p>从上图，其实很容易看出，第一条指令：</p>
<pre class="screen">add r0, r1,$5</pre>
<p>执行的时候，此时PC已经指向第三条指令：</p>
<pre class="screen">cmp r2,#3</pre>
<p>的地址了，所以，是PC=PC+8.</p>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="idp3138744"></a>3.4.1.&nbsp;为何ARM9和ARM7一样，也是PC=PC+8</h3></div></div></div>
<p>ARM7的三条流水线，PC=PC+8，很好理解，但是AMR9中，是五级流水线，为何还是PC=PC+8，而不是</p>
<p>PC</p>
<p>=PC+(5-1)*4</p>
<p>=PC + 16，</p>
<p>呢？</p>
<p>下面就需要好好解释一番了。</p>
<p>具体解释之前，先贴上ARM7和ARM9的流水线的区别和联系：</p>
<div class="figure">
<a name="fg.arm7_3tie_vs_arm9_5tie"></a><p class="title"><b>图&nbsp;3.4.&nbsp;ARM7三级流水线 vs ARM9五级流水线</b></p>
<div class="figure-contents"><div class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tbody><tr><td align="left"><img src="./Uboot中start.S源码的指令级的详尽解析_files/arm7_3tie_vs_arm9_5tie.png" align="left" alt="ARM7三级流水线 vs ARM9五级流水线"></td></tr></tbody></table></div></div>
</div>
<br class="figure-break"><div class="figure">
<a name="fg.arm7_3tie_mapping_arm9_5tie"></a><p class="title"><b>图&nbsp;3.5.&nbsp;ARM7三级流水线到ARM9五级流水线的映射</b></p>
<div class="figure-contents"><div class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tbody><tr><td align="left"><img src="./Uboot中start.S源码的指令级的详尽解析_files/arm7_3tie_mapping_arm9_5tie.png" align="left" alt="ARM7三级流水线到ARM9五级流水线的映射"></td></tr></tbody></table></div></div>
</div>
<br class="figure-break"><p>下面开始对为何ARM9也是PC=PC+8进行解释。</p>
<p>先列出ARM9的五级流水线的示例：</p>
<div class="figure">
<a name="fg.arm9_5tie_pipeline"></a><p class="title"><b>图&nbsp;3.6.&nbsp;ARM9的五级流水线示例</b></p>
<div class="figure-contents"><div class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tbody><tr><td align="left"><img src="./Uboot中start.S源码的指令级的详尽解析_files/arm9_5tie_pipeline.jpg" align="left" alt="ARM9的五级流水线示例"></td></tr></tbody></table></div></div>
</div>
<br class="figure-break"><p><span class="emphasis"><em>举例分析为何PC=PC+8</em></span></p>
<p>然后我们以下面uboot中的start.S的最开始的汇编代码为例来进行解释：</p>
<pre class="screen">00000000 &lt;_start&gt;:
   0:	ea000014 	b	58 &lt;reset&gt;
   4:	e59ff014 	ldr	pc, [pc, #20]	; 20 &lt;_undefined_instruction&gt;
   8:	e59ff014 	ldr	pc, [pc, #20]	; 24 &lt;_software_interrupt&gt;
   c:	e59ff014 	ldr	pc, [pc, #20]	; 28 &lt;_prefetch_abort&gt;
  10:	e59ff014 	ldr	pc, [pc, #20]	; 2c &lt;_data_abort&gt;
  14:	e59ff014 	ldr	pc, [pc, #20]	; 30 &lt;_not_used&gt;
  18:	e59ff014 	ldr	pc, [pc, #20]	; 34 &lt;_irq&gt;
  1c:	e59ff014 	ldr	pc, [pc, #20]	; 38 &lt;_fiq&gt;

00000020 &lt;_undefined_instruction&gt;:
  20:	00000120 	.word	0x00000120
        </pre>
<p>下面对每一个指令周期，CPU做了哪些事情，分别详细进行阐述：</p>
<p>在看下面具体解释之前，有一句话要牢记，那就是：</p>
<p>PC不是指向你正在运行的指令，而是</p>
<p><span class="emphasis"><em>PC始终指向你要取的指令的地址</em></span></p>
<p>认识清楚了这个前提，后面的举例讲解，就容易懂了。</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<span class="emphasis"><em>指令周期Cycle1</em></span><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
<span class="emphasis"><em>取指</em></span><p><span class="emphasis"><em>PC总是指向将要读取的指令的地址（即我们常说的，指向下一条指令的地址），而当前PC=4，</em></span></p>
<p>所以去取物理地址为4对对应的指令</p>
<pre class="programlisting">ldr	pc, [pc, #20]</pre>
<p>其对应二进制代码为e59ff014。</p>
<p>此处取指完之后，自动更新PC的值，即PC=PC+4（单个指令占4字节，所以加4）=4+4=8</p>
</li></ol></div>
</li>
<li class="listitem">
<span class="emphasis"><em>指令周期Cycle2</em></span><div class="orderedlist"><ol class="orderedlist" type="a">
<li class="listitem">
<span class="emphasis"><em>译指</em></span><p>翻译指令e59ff014</p>
</li>
<li class="listitem">同时再去<span class="emphasis"><em>取指</em></span><p>PC总是指向将要读取的指令的地址（即我们常说的，指向下一条指令的地址），而当前PC=8，</p>
<p>所以去物理地址为8所对应的指令“ldr	pc, [pc, #20]” 其对应二进制代码为e59ff014。</p>
<p>此处取指完之后，自动更新PC的值，即PC=PC+4=8+4=12=0xc</p>
</li>
</ol></div>
</li>
<li class="listitem">
<span class="emphasis"><em>指令周期Cycle3</em></span><div class="orderedlist"><ol class="orderedlist" type="a">
<li class="listitem">
<span class="emphasis"><em>执行</em></span>（指令）
                        <p>执行“e59ff014”，即</p>
<pre class="programlisting">ldr	pc, [pc, #20]</pre>
<p>所对表达的含义，即PC</p>
<p>= PC + 20</p>
<p>= 12 + 20 </p>
<p>= 32 </p>
<p>= 0x20</p>
<p>此处，只是计算出待会要赋值给PC的值是0x20，这个0x20还只是放在执行单元中内部的缓冲中。</p>
</li>
<li class="listitem">
<span class="emphasis"><em>译指</em></span><p>翻译e59ff014</p>
</li>
<li class="listitem">
<span class="emphasis"><em>取指</em></span><p>此步骤由于是和上面（1）中的执行同步做的，所以，未受到影响，继续取指，而取指的那一时刻，PC为上一Cycle更新后的值，即PC=0xc，所以是去取物理地址为0xc所对应的指令</p>
<pre class="programlisting">ldr	pc, [pc, #20]</pre>
<p>对应二进制为e59ff014</p>
</li>
</ol></div>
</li>
</ol></div>
<p>其实，分析到这里，大家就可以看出：</p>
<p>在Cycle3的时候，PC的值，刚好已经在Cycle1和Cycle2，分别加了4，所以Cycle3的时候，PC=PC+8，而同样道理，对于任何一条指令的，都是在Cycle3，指令的Execute执行阶段，如果用到PC的值，那么PC那一时刻，就是PC=PC+8。</p>
<p>所以，此处虽然是五级流水线，但是却不是PC=PC+16，而是PC=PC+8。</p>
<p>进一步地，我们发现，其实PC=PC+N的N，是和指令的执行阶段所处于流水线的深度有关，即此处指令的执行Execute阶段，是五级流水线中的第三个，而这个第三阶段的Execute和指令的第一个阶段的Fetch取指，相差的值是 3 -1 =2，即两个CPU的Cycle，而每个Cycle都会导致PC=+PC+4，所以，指令到了Execute阶段，才会发现，此时PC已经变成PC=PC+8了。</p>
<p>回过头来反观ARM7的三级流水线，也是同样的道理，指令的Execute执行阶段，是处于指令的第三个阶段，同理，在指令计算数据的时候，如果用到PC，就会发现此时PC=PC+8。</p>
<p>同理，假如ARM9的五级流水线，把指令的Execute执行阶段，设计在了第四个阶段，那么就是PC=PC+（第4阶段-1）*4个字节 = PC= PC+12了。</p>
<p></p>
<p><span class="emphasis"><em>用图来说明PC=PC+8个过程</em></span></p>
<p>对于上面的文字的分析过程，可能看起来不是太容易理解，所以，下面这里通过图表来表示具体的流程，就更容易看懂了。其中，下图，是以ARM9的五级流水线的内部架构图为基础，而编辑的出来用于说明为何ARM9的五级流水线，也是PC=PC+8：</p>
<div class="figure">
<a name="fg.arm9_5tie_why_pc8"></a><p class="title"><b>图&nbsp;3.7.&nbsp;ARM9的五级流水线中为何PC=PC+8</b></p>
<div class="figure-contents"><div class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tbody><tr><td align="left"><img src="./Uboot中start.S源码的指令级的详尽解析_files/arm9_5tie_why_pc8.jpg" align="left" alt="ARM9的五级流水线中为何PC=PC+8"></td></tr></tbody></table></div></div>
</div>
<br class="figure-break"><p>对于上图中的，第一个指令在执行的时候，是使用到了PC的值，其实，我们可以看到，</p>
<p>对于指令在执行中，不论是否用到PC的值，PC都会按照既定逻辑，没一个cycle，自动增加4的，套用《非诚勿扰2》中的经典对白，即为：</p>
<p><span class="emphasis"><em>你（指令执行的时候）用，</em></span></p>
<p><span class="emphasis"><em>或者不用，</em></span></p>
<p><span class="emphasis"><em>PC就在那里，</em></span></p>
<p><span class="emphasis"><em>自动增4</em></span></p>
<p>所以，经过两个cycle的增4，就到了指令执行的时候，此时PC已经增加了8了，即使你指令执行的时候，没有用到PC的值，其也还是已经加了8了。而一般来说，大多数的指令，肯定也都是没有用到PC的，但是其实任何指令执行的那一时刻，也已经是PC=PC+8，而多数指令没有用到，所以很多人没有注意到这点罢了。</p>
<p></p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip: PC（execute）=PC（fetch）+ 8">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[提示]" src="./Uboot中start.S源码的指令级的详尽解析_files/tip.png"></td>
<th align="left">PC（execute）=PC（fetch）+ 8</th>
</tr>
<tr><td align="left" valign="top">
<p>对于PC=PC+8中的两个PC，其实含义不完全一样.其更准确的表达，应该是这样：</p>
<p><span class="emphasis"><em>PC（execute）=PC（fetch）+ 8</em></span></p>
<p>其中：</p>
<p>PC（fetch）：当前正在执行的指令，就是之前取该指令时候的PC的值</p>
<p>PC（execute）：当前指令执行的计算中，如果用到PC，则此时PC的值。</p>
</td></tr>
</tbody></table></div>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip: 不同阶段的PC值的关系">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[提示]" src="./Uboot中start.S源码的指令级的详尽解析_files/tip.png"></td>
<th align="left">不同阶段的PC值的关系</th>
</tr>
<tr><td align="left" valign="top">
<p>对应地，在ARM7的三级流水线（取指，译指，执行）和ARM9的五级流水线（取指，译指，执行，存储，写回）中，可以这么说：</p>
<p>PC，  总是指向当前正在被取指的指令的地址，</p>
<p>PC-4，总是指向当前正在被译指的指令的地址，</p>
<p>PC-8，总是指向当前的那条指令，即我们一般说的，正在被执行的指令的地址。</p>
</td></tr>
</tbody></table></div>
<p></p>
<p>【总结】</p>
<p>ARM7的三级流水线，PC=PC+8，</p>
<p>ARM9的五级流水线，也是PC=PC+8，</p>
<p>根本的原因是，两者的流水线设计中，指令的Execute执行阶段，都是处于流水线的第三级。</p>
<p>所以使得PC=PC+8。</p>
<p>类似地，可以推导出：</p>
<p><span class="emphasis"><em>假设，Execute阶段处于流水线中的第E阶段，每条指令是T个字节，那么</em></span></p>
<p><span class="emphasis"><em>PC</em></span></p>
<p><span class="emphasis"><em>= PC + N*T</em></span></p>
<p><span class="emphasis"><em>= PC + (E - 1) * T</em></span></p>
<p><span class="emphasis"><em>此处ARM7和ARM9：</em></span></p>
<p><span class="emphasis"><em>Execute阶段都是第3阶段 ⇒ E=3</em></span></p>
<p><span class="emphasis"><em>每条指令是4个字节      ⇒ T=4</em></span></p>
<p><span class="emphasis"><em>所以：</em></span></p>
<p><span class="emphasis"><em>PC</em></span></p>
<p><span class="emphasis"><em>=PC + N* T</em></span></p>
<p><span class="emphasis"><em>=PC + (3 -1 ) * 4</em></span></p>
<p><span class="emphasis"><em>= PC + 8</em></span></p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip: 关于直接改变PC的值，会导致流水线清空的解释">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[提示]" src="./Uboot中start.S源码的指令级的详尽解析_files/tip.png"></td>
<th align="left">关于直接改变PC的值，会导致流水线清空的解释</th>
</tr>
<tr><td align="left" valign="top"><p>把PC的值直接赋值为0x20。而PC值更改，直接导致流水线的清空，即导致下一个cycle中的，对应的流水线中的其他几个步骤，包括接下来的同一个Cycle中的取指的工作被取消。在PC跳转到0x20的位置之后，流水线重新计算，重新一步步地按照流水线的逻辑，去一点点执行。当然要保证当前指令的执行完成，即执行之后，还有两个cycle，分别做的Memory和Write，会继续执行完成。</p></td></tr>
</tbody></table></div>
</div>
</div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="arm_reg_name_apcs"></a>3.5.&nbsp;AMR寄存器的别名 + APCS</h2></div></div></div>
<p>此处简单介绍一下，ARM寄存器的别名，以及什么是APCS。</p>
<p>用文字解释之前，先看这个版本的解释，显得很直观，很好理解：</p>
<div class="figure">
<a name="fg.aapcs"></a><p class="title"><b>图&nbsp;3.8.&nbsp;ARM Application Procedure Call Standard (AAPCS)</b></p>
<div class="figure-contents"><div class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tbody><tr><td align="left"><img src="./Uboot中start.S源码的指令级的详尽解析_files/aapcs.jpg" align="left" alt="ARM Application Procedure Call Standard (AAPCS)"></td></tr></tbody></table></div></div>
</div>
<br class="figure-break"><div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="arm_reg_alias"></a>3.5.1.&nbsp;ARM中的寄存器的别名</h3></div></div></div>
<p>默认的情况下，这些寄存器只是叫做r0,r1,...,r14等，而APCS 对其起了不同的别名。</p>
<p>使用汇编器预处理器的功能，你可以定义 R0 等名字，但在你修改其他人写的代码的时候，最好还是学习使用 APCS 名字。 </p>
<p>一般编程过程中，最好按照其约定，使用对应的名字，这样使得程序可读性更好。</p>
<p>关于不同寄存器所对应的名字，见下表：</p>
<div class="table">
<a name="tbl.arm_regs_alias"></a><p class="title"><b>表&nbsp;3.2.&nbsp;ARM寄存器的别名</b></p>
<div class="table-contents"><table summary="ARM寄存器的别名" style="border-collapse: collapse;border-top: 1.5pt solid black; border-bottom: 1.5pt solid black; border-left: 1.5pt solid black; border-right: 1.5pt solid black; ">
<colgroup>
<col class="col1">
<col class="col2">
<col class="col3">
</colgroup>
<thead>
<tr><th style="border-bottom: 0.5pt solid green; " colspan="3" align="center">寄存器名字</th></tr>
<tr>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Reg#</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">APCS</th>
<th style="border-bottom: 0.5pt solid green; ">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">R0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">a1</td>
<td style="border-bottom: 0.5pt solid green; ">工作寄存器</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">R1</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">a2</td>
<td style="border-bottom: 0.5pt solid green; ">"</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">R2</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">a3</td>
<td style="border-bottom: 0.5pt solid green; ">"</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">R3</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">a4</td>
<td style="border-bottom: 0.5pt solid green; ">"</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">R4</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">v1</td>
<td style="border-bottom: 0.5pt solid green; ">必须保护</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">R5</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">v2</td>
<td style="border-bottom: 0.5pt solid green; ">"</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">R6</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">v3</td>
<td style="border-bottom: 0.5pt solid green; ">"</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">R7</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">v4</td>
<td style="border-bottom: 0.5pt solid green; ">"</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">R8</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">v5</td>
<td style="border-bottom: 0.5pt solid green; ">"</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">R9</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">v6</td>
<td style="border-bottom: 0.5pt solid green; ">"</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">R10</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">sl</td>
<td style="border-bottom: 0.5pt solid green; ">栈限制</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">R11</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">fp</td>
<td style="border-bottom: 0.5pt solid green; ">桢指针</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">R12</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">ip</td>
<td style="border-bottom: 0.5pt solid green; ">内部过程调用寄存器</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">R13</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">sp</td>
<td style="border-bottom: 0.5pt solid green; ">栈指针</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">R14</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">lr</td>
<td style="border-bottom: 0.5pt solid green; ">连接寄存器</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; ">R15</td>
<td style="border-right: 0.5pt solid green; ">pc</td>
<td style="">程序计数器</td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>更加详细一点，见下：</p>
<div class="blockquote"><blockquote class="blockquote">
<p><a class="ulink" href="http://www.keil.com/support/man/docs/armasm/armasm_ch03s03s01.htm" target="_top">Predeclared register names</a></p>
<p>The following register names are predeclared:</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<span class="emphasis"><em>r0-r15</em></span> and <span class="emphasis"><em>R0-R15</em></span>
</li>
<li class="listitem">
<span class="emphasis"><em>a1-a4</em></span> (argument, result, or scratch registers, synonyms for r0 to r3)</li>
<li class="listitem">
<span class="emphasis"><em>v1-v8</em></span> (variable registers, r4 to r11)</li>
<li class="listitem">
<span class="emphasis"><em>sb</em></span> and <span class="emphasis"><em>SB</em></span> (static base, r9)</li>
<li class="listitem">
<span class="emphasis"><em>ip</em></span> and <span class="emphasis"><em>IP</em></span> (intra-procedure-call scratch register, r12)</li>
<li class="listitem">
<span class="emphasis"><em>sp</em></span> and <span class="emphasis"><em>SP</em></span> (stack pointer, r13)</li>
<li class="listitem">
<span class="emphasis"><em>lr</em></span> and <span class="emphasis"><em>LR</em></span> (link register, r14)</li>
<li class="listitem">
<span class="emphasis"><em>pc</em></span> and <span class="emphasis"><em>PC</em></span> (program counter, r15).</li>
</ol></div>
<p><a class="ulink" href="http://www.keil.com/support/man/docs/armasm/armasm_ch03s03s02.htm" target="_top">Predeclared extension register names</a></p>
<p>The following extension register names are predeclared:</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<span class="emphasis"><em>d0-d31</em></span> and <span class="emphasis"><em>D0-D31</em></span>(VFP double-precision registers)</li>
<li class="listitem">
<span class="emphasis"><em>s0-s31</em></span> and <span class="emphasis"><em>S0-S31</em></span>(VFP single-precision registers)</li>
</ol></div>
<p><a class="ulink" href="http://www.keil.com/support/man/docs/armasm/armasm_ch03s03s03.htm" target="_top">Predeclared coprocessor names</a></p>
<p>The following coprocessor names and coprocessor register names are predeclared:</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">p0-p15 (coprocessors 0-15)</li>
<li class="listitem">c0-c15 (coprocessor registers 0-15).</li>
</ol></div>
</blockquote></div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="what_is_apcs"></a>3.5.2.&nbsp;什么是APCS</h3></div></div></div>
<p><span class="emphasis"><em>APCS</em></span>，ARM 过程调用标准(ARM Procedure Call Standard)，提供了紧凑的编写例程的一种机制，定义的例程可以与其他例程交织在一起。最显著的一点是对这些例程来自哪里没有明确的限制。它们可以编译自 C、 Pascal、也可以是用汇编语言写成的。 </p>
<p>APCS 定义了: </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">对寄存器使用的限制。 </li>
<li class="listitem">使用栈的惯例。 </li>
<li class="listitem">在函数调用之间传递/返回参数。 </li>
<li class="listitem">可以被"回溯"的基于栈的结构的格式，用来提供从失败点到程序入口的函数(和给予的参数)的列表。</li>
</ul></div>
</div>
</div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="why_c_need_stack"></a>3.6.&nbsp;为何C语言（的函数调用）需要堆栈，而汇编语言却不需要堆栈</h2></div></div></div>
<p>之前看了很多关于uboot的分析，其中就有说要为C语言的运行，准备好堆栈。</p>
<p>而自己在Uboot的start.S汇编代码中，关于系统初始化，也看到有堆栈指针初始化这个动作。但是，从来只是看到有人说系统初始化要初始化堆栈，即正确给堆栈指针sp赋值，但是却从来没有看到有人解释，为何要初始化堆栈。所以，接下来的内容，就是经过一定的探究，试图来解释一下，为何要初始化堆栈，即：</p>
<p><span class="emphasis"><em>为何C语言的函数调用要用到堆栈，而汇编却不需要初始化堆栈。</em></span></p>
<p>要明白这个问题，首先要了解堆栈的作用。</p>
<p>关于堆栈的作用，要详细讲解的话，要很长的篇幅，所以此处只是做简略介绍。</p>
<p>总的来说，堆栈的作用就是：保存现场/上下文，传递参数。</p>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="save_context"></a>3.6.1.&nbsp;保存现场/上下文</h3></div></div></div>
<p>现场，意思就相当于案发现场，总有一些现场的情况，要记录下来的，否则被别人破坏掉之后，你就无法恢复现场了。而此处说的现场，就是指CPU运行的时候，用到了一些寄存器，比如r0,r1等等，对于这些寄存器的值，如果你不保存而直接跳转到子函数中去执行，那么很可能就被其破坏了，因为其函数执行也要用到这些寄存器。</p>
<p>因此，在函数调用之前，应该将这些寄存器等现场，暂时保持起来，等调用函数执行完毕返回后，再恢复现场。这样CPU就可以正确的继续执行了。</p>
<p>在计算机中，你常可以看到上下文这个词，对应的英文是context。那么：</p>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="idp1816936"></a>3.6.1.1.&nbsp;什么叫做上下文context</h4></div></div></div>
<p>保存现场，也叫保存上下文。</p>
<p>上下文，英文叫做context，就是上面的文章，和下面的文章，即与你此刻，当前CPU运行有关系的内容，即那些你用到寄存器。所以，和上面的现场，是一个意思。</p>
<p>保存寄存器的值，一般用的是push指令，将对应的某些寄存器的值，一个个放到堆栈中，把对应的值压入到堆栈里面，即所谓的<span class="emphasis"><em>压栈</em></span>。</p>
<p>然后待被调用的子函数执行完毕的时候，再调用pop，把堆栈中的一个个的值，赋值给对应的那些你刚开始压栈时用到的寄存器，把对应的值从堆栈中弹出去，即所谓的<span class="emphasis"><em>出栈</em></span>。</p>
<p>其中保存的寄存器中，也包括lr的值（因为用bl指令进行跳转的话，那么之前的pc的值是存在lr中的），然后在子程序执行完毕的时候，再把堆栈中的lr的值pop出来，赋值给pc，这样就实现了子函数的正确的返回。</p>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="pass_parameter"></a>3.6.2.&nbsp;传递参数</h3></div></div></div>
<p>C语言进行函数调用的时候，常常会传递给被调用的函数一些参数，对于这些C语言级别的参数，被编译器翻译成汇编语言的时候，就要找个地方存放一下，并且让被调用的函数能够访问，否则就没发实现传递参数了。对于找个地方放一下，分两种情况。</p>
<p>一种情况是，本身传递的参数就很少，就可以通过寄存器传送参数。</p>
<p>因为在前面的保存现场的动作中，已经保存好了对应的寄存器的值，那么此时，这些寄存器就是空闲的，可以供我们使用的了，那就可以放参数，而参数少的情况下，就足够存放参数了，比如参数有2个，那么就用r0和r1存放即可。（关于参数1和参数2，具体哪个放在r0，哪个放在r1，就是和APCS中的“在函数调用之间传递/返回参数”相关了，APCS中会有详细的约定。感兴趣的自己去研究。）</p>
<p>但是如果参数太多，寄存器不够用，那么就得把多余的参数堆栈中了。</p>
<p>即，可以用堆栈来传递所有的或寄存器放不下的那些多余的参数。</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="exampe_show_c_stack"></a>3.6.3.&nbsp;举例分析C语言函数调用是如何使用堆栈的</h3></div></div></div>
<p>对于上面的解释的堆栈的作用显得有些抽象，此处再用例子来简单说明一下，就容易明白了：</p>
<p>用:</p>
<pre class="screen">arm-inux-objdump –d u-boot &gt; dump_u-boot.txt</pre>
<p>可以得到dump_u-boot.txt文件。该文件就是中，包含了u-boot中的程序的可执行的汇编代码，其中我们可以看到C语言的函数的源代码，到底对应着那些汇编代码。</p>
<p>下面贴出两个函数的汇编代码，</p>
<p>一个是clock_init，另一个是与clock_init在同一C源文件中的，另外一个函数CopyCode2Ram</p>
<div class="programlistingco">
<pre class="programlisting">            
33d0091c &lt;CopyCode2Ram&gt;:
33d0091c:	e92d4070 	<span class="emphasis"><em>push	{r4, r5, r6, lr}</em></span><a class="co" name="co.cp2ram_1st_line" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.cp2ram_1st_line"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a>
33d00920:	e1a06000 	mov	r6, r0
33d00924:	e1a05001 	mov	r5, r1
33d00928:	e1a04002 	mov	r4, r2
33d0092c:	ebffffef 	bl	33d008f0 &lt;bBootFrmNORFlash&gt;<a class="co" name="co.call_bootfromnor" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.call_bootfromnor"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a>
... ...
33d00984:	ebffff14 	bl	33d005dc &lt;nand_read_ll&gt;
... ...
33d009a8:	e3a00000 	mov	r0, #0	; 0x0<a class="co" name="co.cp2ram_mov_r0" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.cp2ram_mov_r0"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/3.png" alt="3" border="0"></span></a>
33d009ac:	e8bd8070 	<span class="emphasis"><em>pop	{r4, r5, r6, pc}</em></span><a class="co" name="co.cp2ram_last_line" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.cp2ram_last_line"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/4.png" alt="4" border="0"></span></a>

33d009b0 &lt;clock_init&gt;:
33d009b0:	e3a02313 	mov	r2, #1275068416	; 0x4c000000<a class="co" name="co.clock_init_1st_line" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.clock_init_1st_line"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/5.png" alt="5" border="0"></span></a>
33d009b4:	e3a03005 	mov	r3, #5	; 0x5
33d009b8:	e5823014 	str	r3, [r2, #20]
... ...
33d009f8:	e1a0f00e 	<span class="emphasis"><em>mov	pc, lr</em></span><a class="co" name="co.clock_init_last_line" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.note.clock_init_last_line"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/6.png" alt="6" border="0"></span></a>
            </pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tbody><tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.cp2ram_1st_line"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.cp2ram_1st_line"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/1.png" alt="1" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>此处就是我们所期望的，用push指令，保存了r4,r5,r以及lr。</p>
<p>用push去保存r4,r5,r6，那是因为所谓的保存现场，以后后续函数返回时候再恢复现场，</p>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.call_bootfromnor"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.call_bootfromnor"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/2.png" alt="2" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>上述用push去保存lr，那是因为函数CopyCode2Ram里面在此处调用了bBootFrmNORFlash</p>
<p>以及也调用了nand_read_ll：</p>
<pre class="screen">33d00984:	ebffff14 	bl	33d005dc &lt;nand_read_ll&gt;</pre>
<p>也用到了bl指令，会改变我们最开始进入clock_init时候的lr的值，所以我们要用push也暂时保存起来。</p>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.cp2ram_mov_r0"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.cp2ram_mov_r0"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/3.png" alt="3" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>把0赋值给r0寄存器，这个就是我们所谓返回值的传递，是通过r0寄存器的。</p>
<p>此处的返回值是0，也对应着C语言的源码中的“return 0”.</p>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.cp2ram_last_line"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.cp2ram_last_line"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/4.png" alt="4" border="0"></span></a> </p></td>
<td valign="top" align="left"><p>把之前push的值，给pop出来，还给对应的寄存器，其中最后一个是将开始push的lr的值，pop出来给赋给PC，因为实现了函数的返回。</p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.clock_init_1st_line"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.clock_init_1st_line"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/5.png" alt="5" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>可以看到此处是该函数第一行</p>
<p>其中没有我们所期望的push指令，没有去将一些寄存器的值放到堆栈中。这是因为，我们clock_init这部分的内容，所用到的r2,r3等寄存器，和前面调用clock_init之前所用到的寄存器r0，没有冲突，所以此处可以不用push去保存这类寄存器的值，不过有个寄存器要注意，那就是r14，即lr，其是在前面调用clock_init的时候，用的是bl指令，所以会自动把跳转时候的pc的值赋值给lr，所以也不需要push指令去将PC的值保存到堆栈中。</p>
</td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="co.note.clock_init_last_line"></a><a href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#co.clock_init_last_line"><span><img src="./Uboot中start.S源码的指令级的详尽解析_files/6.png" alt="6" border="0"></span></a> </p></td>
<td valign="top" align="left">
<p>而此处是clock_init的代码的最后一行</p>
<p>就是我们常见的mov pc, lr，把lr的值，即之前保存的函数调用时候的PC值，赋值给现在的PC，这样就实现了函数的正确的返回，即返回到了函数调用时候下一个指令的位置。</p>
<p>这样CPU就可以继续执行原先函数内剩下那部分的代码了。</p>
</td>
</tr>
</tbody></table></div>
</div>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip: 对于使用哪个寄存器来传递返回值">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[提示]" src="./Uboot中start.S源码的指令级的详尽解析_files/tip.png"></td>
<th align="left">对于使用哪个寄存器来传递返回值</th>
</tr>
<tr><td align="left" valign="top"><p>当然你也可以用其他暂时空闲没有用到的寄存器来传递返回值，但是这些处理方式，本身是根据ARM的APCS的寄存器的使用的约定而设计的，你最好不要随便改变使用方式，最好还是按照其约定的来处理，这样程序更加符合规范。</p></td></tr>
</tbody></table></div>
</div>
</div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="why_adr_not_move"></a>3.7.&nbsp;关于为何不直接用mov指令，而非要用adr伪指令</h2></div></div></div>
<p>在分析uboot的start.S中，看到一些指令，比如：</p>
<pre class="programlisting">adr r0, _start</pre>
<p>觉得好像可以直接用mov指令实现即可，为啥还要这么麻烦地，去用ldr去实现？</p>
<p>关于此处的代码，为何要用adr指令：</p>
<pre class="programlisting">adr r0, _start</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: adr r0, _start会被翻译为真正的汇编指令">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="./Uboot中start.S源码的指令级的详尽解析_files/note.png"></td>
<th align="left">
<a name="note.translated_to_real_assembly"></a>adr r0, _start会被翻译为真正的汇编指令</th>
</tr>
<tr><td align="left" valign="top">
<p>其被编译器编译后，会被翻译成：</p>
<pre class="programlisting">sub	r0, pc, #172</pre>
</td></tr>
</tbody></table></div>
<p>而不直接用mov指令直接将_start的值赋值给r0，类似于这样：</p>
<pre class="programlisting">mov r0, _start</pre>
<p>呢？</p>
<p>其原因主要是,</p>
<pre class="programlisting">sub	r0, pc, #172</pre>
<p>这样的代码，所处理的值，都是相对于PC的偏移量来说的，这样的代码中，没有绝对的物理地址值，都是相对的值，利用产生位置无关代码。因为如果用mov指令：</p>
<pre class="programlisting">mov r0, _start</pre>
<p>那么就会被编译成这样的代码：</p>
<pre class="programlisting">mov r0, 0x33d00000</pre>
<p>如果用了上面这样的代码：</p>
<pre class="programlisting">mov r0, 0x33d00000</pre>
<p>那么，如果整个代码，即要执行的程序的指令，被移动到其他位置，那么</p>
<pre class="programlisting">mov r0, 0x33d00000</pre>
<p>这行指令，执行的功能，就是跳转到绝对的物理地址，而不是跳转到相对的_start的位置了，就不能实现我们想要的功能了，这样包含了绝对物理地址的代码，也就不是位置无关的代码了。</p>
<p>与此相对，这行指令：</p>
<pre class="programlisting">sub	r0, pc, #172</pre>
<p>即使程序被移动到其他位置，那么该行指令还是可以跳转到相对PC往前172字节的地方，也还是我们想要的_start的位置，这样包含的都是相对的偏移位置的代码，就叫做位置无关代码。其优点就是不用担心你的代码被移动，即使程序的基地址变了，所有的代码的相对位置还是固定的，程序还是可以正常运行的。</p>
<p>关于，之所以不用上面的：</p>
<pre class="programlisting">mov r0, 0x33d00000</pre>
<p>类似的代码，除了上面说的，不是位置无关的代码之外，其还有个潜在的问题，那就是，关于mov指令的源操作数，此处即为0x33d00000，不一定是合法的mov 指令所允许的值，这也正是下面要详细解释的内容<a class="xref" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/html/uboot_starts_analysis.html#mov_value_range" title="3.8. mov指令的操作数的取值范围到底是多少">第&nbsp;3.8&nbsp;节 “mov指令的操作数的取值范围到底是多少”</a></p>
<p>【总结】</p>
<p><span class="emphasis"><em>之所以用adr而不用mov，主要是为了生成地址无关代码，以及由于不方便判断一个数，是否是有效的mov的操作数。</em></span></p>
</div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="mov_value_range"></a>3.8.&nbsp;mov指令的操作数的取值范围到底是多少</h2></div></div></div>
<p>关于mov指令操作数的取值范围，网上看到一些人说是0x00-0xFF,也有人说是其他的值的，但是经过一番求证，发现这些说法都不对。下面就是来详细解释，mov指令的操作数的取指范围，到底是多少。</p>
<p>在看了我说的，关于这行代码：</p>
<pre class="programlisting">mov r0, 0x33d00000</pre>
<p>的源操作数0x33d0000，可能是mov指令所不允许的，这句话后，可能有人会说，我知道，那是因为mov的操作数的值，不允许大于255,至少网上很多人的资料介绍中，都是这么说的。</p>
<p>对此，要说的是，你的回答是错误的。</p>
<p>关于mov操作数的真正的允许的取值范围，还真的不是那么容易就能搞懂的，下面就来详细解释解释。</p>
<p>总的来说，我是从<a class="ulink" href="http://blog.chinaunix.net/space.php?uid=20799298&amp;do=blog&amp;cuid=2055392" target="_top">ARM 汇编的mov操作立即数的疑问</a></p>
<p>里面，才算清楚mov的取值范围，以及找了相应的datasheet，才最终看懂整个事情的来龙去脉的。</p>
<p>首先，mov的指令，是属于ARM指令集中，数据处理（Data Process）分类中的其中一个指令，</p>
<p>而数据处理指令的具体格式是：<a class="ulink" href="http://netwinder.osuosl.org/pub/netwinder/docs/arm/ARM7500FEvB_3.pdf" target="_top">ARM Processor Instruction Set</a></p>
<div class="figure">
<a name="fg.data_process_instr"></a><p class="title"><b>图&nbsp;3.9.&nbsp;数据处理指令的指令格式</b></p>
<div class="figure-contents"><div class="mediaobject" align="left"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tbody><tr><td align="left"><img src="./Uboot中start.S源码的指令级的详尽解析_files/data_process_instr.png" align="left" alt="数据处理指令的指令格式"></td></tr></tbody></table></div></div>
</div>
<br class="figure-break"><p>对于此格式，我们可以拿：</p>
<pre class="screen">arm-linux-objdump –d u-boot &gt; dump_u-boot.txt</pre>
<p>中得到的汇编代码中关于：</p>
<pre class="programlisting">ldr     r0, =0x53000000</pre>
<p>所对应的，真正的汇编代码：</p>
<pre class="programlisting">33d00068:	e3a00453 	mov	r0, #1392508928	; 0x53000000</pre>
<p>来分析，就容易看懂了：</p>
<p>mov	r0, #1392508928 </p>
<p>= mov	r0, #0x53000000</p>
<p>的作用就是，把0x53000000移动到r0中去。</p>
<p>其对应的二进制指令是上面的：</p>
<p>0xe3a00453 = 1110 0011 1010 0000 0000 0100 0101 0011 b</p>
<p>下面对照mov指令的格式，来分析这些位所对应的含义：</p>
<div class="table">
<a name="tbl.mov_0xe3a00453_bits"></a><p class="title"><b>表&nbsp;3.3.&nbsp;mov指令0xe3a00453的位域含义解析</b></p>
<div class="table-contents"><table summary="mov指令0xe3a00453的位域含义解析" style="border-collapse: collapse;border-top: 1.5pt solid black; border-bottom: 1.5pt solid black; border-left: 1.5pt solid black; border-right: 1.5pt solid black; ">
<colgroup>
<col class="col1">
<col class="col2">
<col class="col3">
<col class="col4">
<col class="col5">
<col class="col6">
<col class="col7">
<col class="col8">
<col class="col9">
</colgroup>
<thead><tr>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">31-28</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">27-26</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">25</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">24-21</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">20</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">19-16</th>
<th style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">15-12</th>
<th style="border-bottom: 0.5pt solid green; " colspan="2" align="center">11-0</th>
</tr></thead>
<tbody>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">Condition Field</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">00</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">
<span class="emphasis"><em>I</em></span>(Immediate Operand)</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">
<span class="emphasis"><em>OpCode</em></span>(Operation Code)</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">
<span class="emphasis"><em>S</em></span>(Set Condition Code)</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">
<span class="emphasis"><em>Rn</em></span>(1st Operand Register)</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">
<span class="emphasis"><em>Rd</em></span>(Destination Register)</td>
<td style="border-bottom: 0.5pt solid green; " colspan="2" align="center">Operand 2<div class="literallayout"><p>1&nbsp;=&nbsp;operand<br>
2&nbsp;is&nbsp;an&nbsp;immediate&nbsp;value</p></div>
</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">&nbsp;</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">&nbsp;</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">&nbsp;</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">&nbsp;</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">&nbsp;</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">&nbsp;</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">&nbsp;</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">11-8:Rotate
</td>
<td style="border-bottom: 0.5pt solid green; ">7-0:Imm
</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1110</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">00</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">1101</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0000</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0000</td>
<td style="border-right: 0.5pt solid green; border-bottom: 0.5pt solid green; ">0100</td>
<td style="border-bottom: 0.5pt solid green; ">0101 0011</td>
</tr>
<tr>
<td style="border-right: 0.5pt solid green; ">&nbsp;</td>
<td style="border-right: 0.5pt solid green; ">&nbsp;</td>
<td style="border-right: 0.5pt solid green; ">表明是立即数</td>
<td style="border-right: 0.5pt solid green; ">1101对应的是MOV指令</td>
<td style="border-right: 0.5pt solid green; ">&nbsp;</td>
<td style="border-right: 0.5pt solid green; ">MOV指令做的事情是： Rd:= Op2,和Rn无关，所以忽略这个Rn</td>
<td style="border-right: 0.5pt solid green; ">表示0000号寄存器，即r0</td>
<td style="border-right: 0.5pt solid green; ">0100=4,含义参见注释1</td>
<td style="">0x53</td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="./Uboot中start.S源码的指令级的详尽解析_files/note.png"></td>
<th align="left">注意</th>
</tr>
<tr><td align="left" valign="top">
<p>上述datasheet中写到：</p>
<div class="blockquote"><blockquote class="blockquote">
<p>5.4.3 Immediate operand rotates </p>
<p>The immediate operand rotate field is a 4 bit unsigned integer which specifies a shift operation on the 8 bit immediate value. This value is zero extended to 32 bits, and then subject to a <span class="emphasis"><em>rotate right</em></span> by <span class="emphasis"><em>twice</em></span> the value in the rotate field. This enables many common constants to be generated, for example all powers of 2</p>
</blockquote></div>
<p>意思是，对于bit[11:8]的值，是个4位，无符号的整型，其指定了bit[7:0]的8bit立即数值的位移操作。具体如何指定呢，那就是将bit[7:0]的值，循环右移2x bit[11:8]位。</p>
<p>对于我们的例子，就是，将bit[7:0]的值0x53,循环右移 2xbit[11:8]= 2 x 4 = 8位，</p>
<p>而0x53循环右移8位，就得到了0x53000000，就是我们要mov值，mov到目的寄存器rd，此处为r0中。</p>
<p>而上面英文最后一句说的是，通过将bit[7:0]的值,循环右移 2xbit[11:8]的方式，就可以产生出很多个数值了，即mov的操作数中，其中符合可以通过0x00-0xFF循环右移偶数位而产生的数值，都是合法的mov的操作数，而这样的数，其实是很多的。</p>
</td></tr>
</tbody></table></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: 总结mov取值范围">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="./Uboot中start.S源码的指令级的详尽解析_files/note.png"></td>
<th align="left">
<a name="note.summary_mov_range"></a>总结mov取值范围</th>
</tr>
<tr><td align="left" valign="top">
<p>所以，<span class="emphasis"><em>mov指令的操作数的真正的取指范围</em></span>，即不是0-0xFF（0-255），也不是只有2的倍数，而是：</p>
<p><span class="emphasis"><em>只要该数，可以通过0x00-0xFF中某个数，循环右移偶数位而产生，就是合法的mov的操作数，否则就是非法的mov的操作数。</em></span></p>
</td></tr>
</tbody></table></div>
</div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="summary_assembly"></a>3.9.&nbsp;汇编学习总结记录</h2></div></div></div>
<p>对于我们之前分析的start.S中，涉及到很多的汇编的语句，其中，可以看出，很多包含了很多种不同的语法，使用惯例等，下面，就对此进行一些总结，借以实现一定的举一反三或者说触类旁通，这样，可以起到一定的借鉴功能，方便以后看其他类似汇编代码， 容易看懂汇编代码所要表达的含义。</p>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="assembly_label_c_label"></a>3.9.1.&nbsp;汇编中的标号=C中的标号</h3></div></div></div>
<p>像前面汇编代码中，有很多的，以点开头，加上一个名字的形式的标号，比如：</p>
<pre class="programlisting">reset:
	/*
	 * set the cpu to SVC32 mode
	 */
	mrs	r0,cpsr
        </pre>
<p>中的reset，就是汇编中的标号，相对来说，比较容易理解，就相当于C语言的标号。</p>
<p>比如，C语言中定义一个标号ERR_NODEV：</p>
<pre class="programlisting">ERR_NODEV: /* no device error */
    ... /* c code here */
        </pre>
<p>然后对应在别处，使用goto去跳转到这个标号ERR_NODEV：</p>
<pre class="programlisting">if (something)
    goto ERR_NODEV ; 
        </pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: 【总结】">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="./Uboot中start.S源码的指令级的详尽解析_files/note.png"></td>
<th align="left">【总结】</th>
</tr>
<tr><td align="left" valign="top"><p><span class="emphasis"><em>汇编中的标号 = C语言中的标号Label</em></span></p></td></tr>
</tbody></table></div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="assembly_b_c_goto"></a>3.9.2.&nbsp;汇编中的跳转指令=C中的goto</h3></div></div></div>
<p>对应地，和上面的例子中的C语言中的编号和掉转到标号的goto类似，汇编中，对于定义了标号，那么也会有对应的指令，去跳转到对应的汇编中的标号。</p>
<p>这些跳转的指令，就是b指令，b是branch的缩写。</p>
<p>b指令的格式是：</p>
<pre class="screen">b{cond} label</pre>
<p>简单说就是跳转到label处。</p>
<p>用和上面的例子相关的代码来举例：</p>
<pre class="programlisting">.globl _start
_start:	b       reset
        </pre>
<p>就是用b指令跳转到上面那个reset的标号。</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: 【总结】">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="./Uboot中start.S源码的指令级的详尽解析_files/note.png"></td>
<th align="left">【总结】</th>
</tr>
<tr><td align="left" valign="top"><p><span class="emphasis"><em>汇编中的b跳转指令 = C语言中的goto</em></span></p></td></tr>
</tbody></table></div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="assembly_globl_c_extern"></a>3.9.3.&nbsp;汇编中的.globl=C语言中的extern</h3></div></div></div>
<p>对于上面例子中：</p>
<pre class="programlisting">.globl _start
        </pre>
<p>中的.global，就是声明_start为全局变量/标号，可以供其他源文件所访问。</p>
<p>即汇编器，在编译此汇编代码的时候，会将此变量记下来，知道其是个全局变量，遇到其他文件是用到此变量的的时候，知道是访问这个全局变量的。</p>
<p>因此，从功能上来说，就相当于C语言用extern去生命一个变量，以实现本文件外部访问此变量。</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: 【总结】">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="./Uboot中start.S源码的指令级的详尽解析_files/note.png"></td>
<th align="left">【总结】</th>
</tr>
<tr><td align="left" valign="top"><p><span class="emphasis"><em>汇编中的.globl或.global = C语言中的extern</em></span></p></td></tr>
</tbody></table></div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="bl_mov_pc_lr_mean_func_call"></a>3.9.4.&nbsp;汇编中用bl指令和mov pc，lr来实现子函数调用和返回</h3></div></div></div>
<p>和b指令类似的，另外还有一个bl指令，语法是：</p>
<pre class="screen">BL{cond} label</pre>
<p>其作用是，除了b指令跳转到label之外，在跳转之前，先把下一条指令地址存到lr寄存器中，以方便跳转到那边执行完毕后，将lr再赋值给pc，以实现函数返回，继续执行下面的指令的效果。</p>
<p>用下面这个start.S中的例子来说明：</p>
<pre class="programlisting">	bl	cpu_init_crit
......
cpu_init_crit:
......
	mov	pc, lr
        </pre>
<p>其中，就是先调用bl掉转到对应的标号cpu_init_crit，其实就是相当于一个函数了，</p>
<p>然后在cpu_init_crit部分，执行完毕后，最后调用 mov pc, lr，将lr中的值，赋给pc，即实现函数的返回原先 bl cpu_init_crit下面那条代码，继续执行函数。</p>
<p>上面的整个过程，用C语言表示的话，就相当于</p>
<pre class="programlisting">......
cpu_init_crit();
......

void cpu_init_crit(void)
{
......
}
        </pre>
<p>而关于C语言中，<span class="emphasis"><em>函数的跳转前后所要做的事情</em></span>，都是C语言编译器帮我们实现好了，会将此C语言中的函数调用，转化为对应的汇编代码的。</p>
<p>其中，此处所说的，函数掉转前后所要做的事情，就是：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
<span class="emphasis"><em>函数跳转前</em></span><p>要将当前指令的下一条指令的地址，保存到lr寄存器中</p>
</li>
<li class="listitem">
<span class="emphasis"><em>函数调用完毕后</em></span><p>将之前保存的lr的值给pc，实现函数跳转回来。继续执行下一条指令。</p>
</li>
</ul></div>
<p>而如果你本身自己写汇编语言的话，那么这些函数跳转前后要做的事情，都是你程序员自己要关心，要实现的事情。</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: 总结汇编中的：bl + mov pc，lr">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="./Uboot中start.S源码的指令级的详尽解析_files/note.png"></td>
<th align="left">
<a name="note.bl_mov_pc_lr"></a>总结汇编中的：bl + mov pc，lr</th>
</tr>
<tr><td align="left" valign="top"><p><span class="emphasis"><em>汇编中bl + mov pc，lr = C语言中的子函数调用和返回</em></span></p></td></tr>
</tbody></table></div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="assembly_label_c_pointer"></a>3.9.5.&nbsp;汇编中的对应位置有存储值的标号 = C语言中的指针变量</h3></div></div></div>
<p>像前文所解析的代码中类似于这样的：</p>
<pre class="screen">LABEL1：.word Value2</pre>
<p>比如：</p>
<pre class="programlisting">_TEXT_BASE:
	.word	TEXT_BASE
        </pre>
<p>所对应的含义是，有一个标号_TEXT_BASE</p>
<p>而该标号中对应的位置，所存放的是一个word的值，具体的数值是TEXT_BASE，此处的TEXT_BASE是在别处定义的一个宏，值是0x33D00000。</p>
<p>所以，即为：</p>
<p>有一个标号_TEXT_BASE，其对应的位置中，所存放的是一个word的值，值为</p>
<pre class="screen">TEXT_BASE=0x33D00000</pre>
<p>总的来说，此种用法的含义，如果用C语言来表示，其实更加容易理解：</p>
<pre class="programlisting">int *_TEXT_BASE = TEXT_BASE = 0x33D00000</pre>
<p>即：</p>
<pre class="programlisting">int *_TEXT_BASE = 0x33D00000</pre>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip: C语言中如何引用汇编中的标号">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[提示]" src="./Uboot中start.S源码的指令级的详尽解析_files/tip.png"></td>
<th align="left">
<a name="tip.c_call_assembly_label"></a>C语言中如何引用汇编中的标号</th>
</tr>
<tr><td align="left" valign="top">
<p>不过，对于这样的类似于C语言中的指针的汇编中的标号，在C语言中调用到的话，却是这样引用的：</p>
<pre class="programlisting">/* for the following variables, see start.S */
extern ulong _armboot_start;	/* code start */
extern ulong _bss_start;	/* code + data end == BSS start */
......
	IRQ_STACK_START = _armboot_start - CFG_MALLOC_LEN - CFG_GBL_DATA_SIZE - 4;
......
            </pre>
<p>而不是我原以为的，直接当做指针来引用该变量的方式：</p>
<pre class="programlisting">	*IRQ_STACK_START = *_armboot_start - CFG_MALLOC_LEN - CFG_GBL_DATA_SIZE - 4;
            </pre>
<p>其中，对应的汇编中的代码为：</p>
<pre class="programlisting">.globl _armboot_start
_armboot_start:
	.word _start
            </pre>
<p>所以，针对这点，还是需要注意一下的。至少以后如果自己写代码的时候，在C语言中引用汇编中的global的标号的时候，知道是如何引用该变量的。</p>
</td></tr>
</tbody></table></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: 【总结】">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="./Uboot中start.S源码的指令级的详尽解析_files/note.png"></td>
<th align="left">【总结】</th>
</tr>
<tr><td align="left" valign="top">
<p><span class="emphasis"><em>汇编中类似这样的代码：</em></span></p>
<p><span class="emphasis"><em>label1: .word value2</em></span></p>
<p><span class="emphasis"><em>就相当于C语言中的：</em></span></p>
<p><span class="emphasis"><em>int *label1 = value2</em></span></p>
<p><span class="emphasis"><em>但是在C语言中引用该标号/变量的时候，却是直接拿来用的，就像这样：</em></span></p>
<p><span class="emphasis"><em>label1 = other_value</em></span></p>
<p><span class="emphasis"><em>其中label1就是个int型的变量。</em></span></p>
</td></tr>
</tbody></table></div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="assembly_ldr_c_func_call"></a>3.9.6.&nbsp;汇编中的ldr+标号，来实现C中的函数调用</h3></div></div></div>
<p>接着上面的内容，继续解释，对于汇编中这样的代码：</p>
<p>第一种：</p>
<pre class="programlisting">ldr pc, 标号1
......
标号1：.word 标号2
......
标号2：
	......（具体要执行的代码）
        </pre>
<p>或者是，</p>
<p>第二种：</p>
<pre class="programlisting">ldr pc, 标号1
......
标号1：.word XXX（C语言中某个函数的函数名）
        </pre>
<p>的意思就是，将地址为标号1中内容载入到pc中。</p>
<p>而地址为标号1中的内容，就是标号2。</p>
<pre class="screen">TEXT_BASE=0x33D00000</pre>
<p>所以上面第一种的意思:</p>
<p>就很容易看出来，就是把标号2这个地址值，给pc，即实现了跳转到标号2的位置执行代码，</p>
<p>就相当于调用一个函数，该函数名为标号2.</p>
<p>第二种的意思，和上面类似，是将C语言中某个函数的函数名，即某个地址值，给pc，实现调用C中对应的那个函数。</p>
<p>两种做法，其含义用C语言表达，其实很简单：</p>
<p><span class="emphasis"><em>PC = *（标号1） = 标号2</em></span></p>
<div class="example">
<a name="idp3302704"></a><p class="title"><b>例&nbsp;3.1.&nbsp;汇编中的ldr加标号实现函数调用 示例</b></p>
<div class="example-contents">
<p>举个例子就是：</p>
<p>第一种：</p>
<pre class="programlisting">......
	ldr	pc, _software_interrupt
......
_software_interrupt:	.word software_interrupt
......
software_interrupt:
	get_bad_stack
	bad_save_user_regs
	bl 	do_software_interrupt
            </pre>
<p>就是实现了将标号1，_software_interrupt，对应的位置中的值，标号2，software_interrupt，给pc，即实现了将pc掉转到software_interrupt的位置，即实现了调用函数software_interrupt的效果。</p>
<p>第二种：</p>
<pre class="programlisting">	ldr	pc, _start_armboot

_start_armboot:	.word start_armboot
            </pre>
<p>含义就是，将标号1，_start_armboot，所对应的位置中的值，start_armboot给pc，即实现了调用函数start_armboot的目的。</p>
<p>其中，start_armboot是C语言文件中某个C语言的函数。</p>
</div>
</div>
<br class="example-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: 总结汇编中实现函数调用的方式">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="./Uboot中start.S源码的指令级的详尽解析_files/note.png"></td>
<th align="left">
<a name="note.assembly_implement_func_call"></a>总结汇编中实现函数调用的方式</th>
</tr>
<tr><td align="left" valign="top">
<p><span class="emphasis"><em>汇编中，实现函数调用的效果，有如下两种方法：</em></span></p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">方法1
                    <pre class="programlisting">ldr pc, 标号1
......
标号1：.word 标号2
......
标号2：
	......（具体要执行的代码）
                    </pre>
</li>
<li class="listitem">方法2
                    <pre class="programlisting">ldr pc, 标号1
......
标号1：.word XXX（C语言中某个函数的函数名）
                    </pre>
</li>
</ol></div>
</td></tr>
</tbody></table></div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="assembly_set_value_for_reg"></a>3.9.7.&nbsp;汇编中设置某个寄存器的值或给某个地址赋值</h3></div></div></div>
<p>在汇编代码start.S中，看到不止一处， 类似于这样的代码：</p>
<p>形式1：</p>
<pre class="programlisting"># define pWTCON		0x53000000
......
	ldr     r0, =pWTCON
	mov     r1, #0x0
	str     r1, [r0]
        </pre>
<p>或者是，</p>
<p>形式2：</p>
<pre class="programlisting"># define INTSUBMSK	0x4A00001C
......
	ldr	r1, =0x7fff
	ldr	r0, =INTSUBMSK
	str	r1, [r0]
        </pre>
<p>其含义，都是将某个值，赋给某个地址，此处的地址，是用宏定义来定义的，对应着某个寄存器的地址。</p>
<p>其中，形式1是直接通过mov指令来将0这个值赋给r1寄存器，和形式2中的通过ldr伪指令来将0x3ff赋给r1寄存器，两者区别是，前者是因为已经确定所要赋的值0x0是mov的有效操作数，而后者对于0x3ff不确定是否是mov的有效操作数</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="./Uboot中start.S源码的指令级的详尽解析_files/warning.png"></td>
<th align="left">警告</th>
</tr>
<tr><td align="left" valign="top">
<p>如果不是，则该指令无效，编译的时候，也无法通过编译，会出现类似于这样的错误：:</p>
<pre class="screen">    start.S: Assembler messages:
    start.S:149: Error: invalid constant -- 'mov r1,#0xFFEFDFFF'
    make[1]: *** [start.o] 错误 1
    make: *** [cpu/arm920t/start.o] 错误 2
            </pre>
</td></tr>
</tbody></table></div>
<p>所以才用ldr伪指令，让编译器来帮你自动判断：</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">如果该操作数是mov的有效操作数，那么ldr伪指令就会被翻译成对应的mov指令
                <div class="example">
<a name="idp3312888"></a><p class="title"><b>例&nbsp;3.2.&nbsp;</b></p>
<div class="example-contents">
<p>举例说明：</p>
<p>汇编代码：</p>
<pre class="programlisting"># define pWTCON		0x53000000
......
	ldr     r0, =pWTCON
                    </pre>
<p>被翻译后的真正的汇编代码：</p>
<pre class="programlisting">33d00068:	e3a00453 	mov	r0, #1392508928	; 0x53000000
                    </pre>
</div>
</div>
<br class="example-break">
</li>
<li class="listitem">如果该操作数不是mov的有效操作数，那么ldr伪指令就会被翻译成ldr指令
                <div class="example">
<a name="idp3314848"></a><p class="title"><b>例&nbsp;3.3.&nbsp;</b></p>
<div class="example-contents">
<p>举例说明：</p>
<p>汇编代码：</p>
<pre class="programlisting">	ldr	r1, =0x7fff
                    </pre>
<p>被翻译后的真正的汇编代码：</p>
<pre class="programlisting">33d00080:	e59f13f8 	<span class="emphasis"><em>ldr	r1, [pc, #1016]</em></span>	; 33d00480 &lt;fiq+0x60&gt;
......
33d00480:	00007fff 	<span class="emphasis"><em>.word	0x00007fff</em></span>
                    </pre>
<p>即把ldr伪指令翻译成真正的ldr指令，并且另外分配了一个word的地址空间用于存放该数值，然后用ldr指令将对应地址中的值载入，赋值给r1寄存器。</p>
</div>
</div>
<br class="example-break">
</li>
</ol></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: 总结汇编中给某个地址赋值的方法">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="./Uboot中start.S源码的指令级的详尽解析_files/note.png"></td>
<th align="left">
<a name="note.assembly_set_addr_value"></a>总结汇编中给某个地址赋值的方法</th>
</tr>
<tr><td align="left" valign="top">
<p><span class="emphasis"><em>汇编中，一个常用的，用来给某个地址赋值的方法，类似如下形式：</em></span></p>
<pre class="programlisting">#define 宏的名字  寄存器地址
......
	ldr	r1, =要赋的值
	ldr	r0, =宏的名字
	str	r1, [r0]
            </pre>
</td></tr>
</tbody></table></div>
</div>
</div>
</div>
<div class="bibliography">
<div class="titlepage"><div><div><h1 class="title">
<a name="reference"></a>参考书目</h1></div></div></div>
<div class="bibliomixed">
<a name="ref.embedsky_tq2440_src"></a><p class="bibliomixed">[1] 
  <span class="bibliosource"><a class="ulink" href="http://bbs.embedsky.net/viewthread.php?tid=859" target="_top">2010年6月 最新TQ2440光盘下载 （Linux内核，WinCE的eboot，uboot均有更新）</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.blobl_word_balignl"></a><p class="bibliomixed">[2] 
  <span class="bibliosource"><a class="ulink" href="http://re-eject.gbadev.org/files/GasARMRef.pdf" target="_top">.globl,.word,.balignl的语法</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.label_explanation"></a><p class="bibliomixed">[3] 
  <span class="bibliosource"><a class="ulink" href="http://sourceware.org/binutils/docs-2.20/as/Labels.html#Labels" target="_top">label的解释</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.ldr_syntax"></a><p class="bibliomixed">[4] 
  <span class="bibliosource"><a class="ulink" href="http://infocenter.arm.com/help/topic/com.arm.doc.dui0206hc/DUI0206HC_rvct_linker_and_utilities_guide.pdf" target="_top">ldr的语法</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.ldr_instruction"></a><p class="bibliomixed">[5] 
  <span class="bibliosource"><a class="ulink" href="http://wenku.baidu.com/view/f7cc280102020740be1e9bea.html" target="_top">ldr指令</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.ldr_instruction_2"></a><p class="bibliomixed">[6] 
  <span class="bibliosource"><a class="ulink" href="http://www.pczpg.com/a/2010/0607/11062.html" target="_top">ldr指令</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.dot_word_syntax"></a><p class="bibliomixed">[7] 
  <span class="bibliosource"><a class="ulink" href="http://blogold.chinaunix.net/u3/115924/showart_2280163.html" target="_top">.word的语法</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.arm7_arch"></a><p class="bibliomixed">[8] 
  <span class="bibliosource"><a class="ulink" href="http://www.docin.com/p-73665362.html" target="_top">ARM7体系结构</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.bootloader"></a><p class="bibliomixed">[9] 
  <span class="bibliosource"><a class="ulink" href="http://www.csie.nctu.edu.tw/~wjtsai/EmbeddedSystemDesign/Ch2-bootloader.pdf" target="_top">bootloader</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.s3c2440_related_material"></a><p class="bibliomixed">[10] 
  <span class="bibliosource"><a class="ulink" href="http://just4you.springnote.com/pages/1052612" target="_top">S3C2440相关的软硬件资料</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.s3c2440_cpu_datasheet"></a><p class="bibliomixed">[11] 
  <span class="bibliosource"><a class="ulink" href="http://just4you.springnote.com/pages/1052612/attachments/803220" target="_top">S3C2440的CPU的datasheet：s3c2440a_um_rev014_040712.pdf</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.fake_instr_ldr_syntax"></a><p class="bibliomixed">[12] 
  <span class="bibliosource"><a class="ulink" href="http://blog.csdn.net/lihaoweiV/archive/2010/11/24/6033003.aspx%20" target="_top">伪指令ldr语法和含义</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.arm9_2410_interrupt"></a><p class="bibliomixed">[13] 
  <span class="bibliosource"><a class="ulink" href="http://www.crifan.com/switch_arm9_2410_transplant_arm_interrupt_principle_the_error_interrupt_nesting_how_come_the_interrupt_number/" target="_top">ARM9 2410移植之ARM中断原理, 中断嵌套的误区，中断号的怎么来的</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.adr_syntax"></a><p class="bibliomixed">[14] 
  <span class="bibliosource"><a class="ulink" href="http://blog.mcuol.com/User/cdkfGao/article/8057_1.htm" target="_top">adr指令的语法和含义</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.arm_co_processor"></a><p class="bibliomixed">[15] 
  <span class="bibliosource"><a class="ulink" href="http://apps.hi.baidu.com/share/detail/32319228" target="_top">ARM协处理器</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.arm920t"></a><p class="bibliomixed">[16] 
  <span class="bibliosource"><a class="ulink" href="http://infocenter.arm.com/help/topic/com.arm.doc.ddi0151c/ARM920T_TRM1_S.pdf" target="_top">ARM920T</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.cp15_meaning"></a><p class="bibliomixed">[17] 
  <span class="bibliosource"><a class="ulink" href="http://www.heyrick.co.uk/assembler/coprocmnd.html" target="_top">CP15的各个寄存器的含义解释</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.icache_dcache"></a><p class="bibliomixed">[18] 
  <span class="bibliosource"><a class="ulink" href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0184b/Chdcfejb.html" target="_top">Invalidate ICache and DCache</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.invalidate_tlb"></a><p class="bibliomixed">[19] 
  <span class="bibliosource"><a class="ulink" href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0184b/Chdifbjc.html" target="_top">Invalidate TLB(s)</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.ctrl_reg"></a><p class="bibliomixed">[20] 
  <span class="bibliosource"><a class="ulink" href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0184b/Chdifbjc.html" target="_top">Control register</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.domain_access_control"></a><p class="bibliomixed">[21] 
  <span class="bibliosource"><a class="ulink" href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0151c/I273867.html" target="_top">Domain access control</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.arm920t_7_mode"></a><p class="bibliomixed">[22] 
  <span class="bibliosource"><a class="ulink" href="http://www.docin.com/p-73665362.html" target="_top">ARM920T的CPU的7种模式</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.arm_linux_kernel_boot"></a><p class="bibliomixed">[23] 
  <span class="bibliosource"><a class="ulink" href="http://www.arm.linux.org.uk/developer/booting.php" target="_top">ARM Linux Kernel Boot Requirements</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.watchdog"></a><p class="bibliomixed">[24] 
  <span class="bibliosource"><a class="ulink" href="http://wenku.baidu.com/view/e5cd52ff04a1b0717fd5dd27.html" target="_top">嵌入式系统之WATCHDOG(看门狗)概述</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.arm_pipeline_pc"></a><p class="bibliomixed">[25] 
  <span class="bibliosource"><a class="ulink" href="http://hi.baidu.com/istry/blog/item/f823e1438de0a71972f05d0f.html" target="_top">ARM流水线和program counter(PC)的增量</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.predeclared_reg_names"></a><p class="bibliomixed">[26] 
  <span class="bibliosource"><a class="ulink" href="http://www.keil.com/support/man/docs/armasm/armasm_ch03s03s01.htm" target="_top">Predeclared register names</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.predeclared_ext_reg_names"></a><p class="bibliomixed">[27] 
  <span class="bibliosource"><a class="ulink" href="http://www.keil.com/support/man/docs/armasm/armasm_ch03s03s02.htm" target="_top">Predeclared extension register names</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.predeclared_coprocessor_name"></a><p class="bibliomixed">[28] 
  <span class="bibliosource"><a class="ulink" href="http://www.keil.com/support/man/docs/armasm/armasm_ch03s03s03.htm" target="_top">Predeclared coprocessor names</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.mov_value_range"></a><p class="bibliomixed">[29] 
  <span class="bibliosource"><a class="ulink" href="http://blog.chinaunix.net/space.php?uid=20799298&amp;do=blog&amp;cuid=2055392" target="_top">mov的操作数的取指范围</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.arm_instrctions_set"></a><p class="bibliomixed">[30] 
  <span class="bibliosource"><a class="ulink" href="http://netwinder.osuosl.org/pub/netwinder/docs/arm/ARM7500FEvB_3.pdf" target="_top">ARM Processor Instruction Set</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.arm9_pc_pc_8"></a><p class="bibliomixed">[31] 
  <span class="bibliosource"><a class="ulink" href="http://blog.csdn.net/hamilton1/archive/2011/02/18/6192722.aspx" target="_top">ARM9流水线PC=PC+8</a></span>
  <span class="author"></span>
</p>
</div>
<div class="bibliomixed">
<a name="ref.strange_behaviour_ldr"></a><p class="bibliomixed">[32] 
  <span class="bibliosource"><a class="ulink" href="http://stackoverflow.com/questions/2102921/strange-behaviour-of-ldr-pc-value" target="_top">Strange behaviour of ldr [pc, #value]</a></span>
  <span class="author"></span>
</p>
</div>
</div>
</div>


</body></html>